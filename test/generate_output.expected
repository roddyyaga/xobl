type xid = int
type file_descr = int
type ('flags, 'vals) mask = F of 'flags list | V of 'vals
type ('enum, 't) alt = E of 'enum | T of 't
module[@warning "-27"] Bigreq = struct
type enable_reply = { maximum_request_length : int32; };;
let enable () : enable_reply Lwt.t = failwith "not implemented";;
end
module[@warning "-27"] Xproto = struct
type char2b = { byte1 : int; byte2 : int; };;
type window = xid;;
type pixmap = xid;;
type cursor = xid;;
type font = xid;;
type gcontext = xid;;
type colormap = xid;;
type atom = xid;;
type drawable = xid;;
type fontable = xid;;
type bool32 = int32;;
type visualid = int32;;
type timestamp = int32;;
type keysym = int32;;
type keycode = int;;
type keycode32 = int32;;
type button = int;;
type point = { x : int; y : int; };;
type rectangle = { x : int; y : int; width : int; height : int; };;
type arc = { x : int; y : int; width : int; height : int; angle1 : int; angle2 : int; };;
type format = { depth : int; bits_per_pixel : int; scanline_pad : int; };;
type visual_class_enum = Static_gray | Gray_scale | Static_color | Pseudo_color | True_color | Direct_color;;
type visualtype = { visual_id : visualid; class_ : visual_class_enum; bits_per_rgb_value : int; colormap_entries : int; red_mask : int32; green_mask : int32; blue_mask : int32; };;
type depth = { depth : int; visuals : visualtype list; };;
type event_mask_mask = ([ `Key_press | `Key_release | `Button_press | `Button_release | `Enter_window | `Leave_window | `Pointer_motion | `Pointer_motion_hint | `Button1_motion | `Button2_motion | `Button3_motion | `Button4_motion | `Button5_motion | `Button_motion | `Keymap_state | `Exposure | `Visibility_change | `Structure_notify | `Resize_redirect | `Substructure_notify | `Substructure_redirect | `Focus_change | `Property_change | `Color_map_change | `Owner_grab_button ], [ `No_event ]) mask;;
type backing_store_enum = Not_useful | When_mapped | Always;;
type screen = { root : window; default_colormap : colormap; white_pixel : int32; black_pixel : int32; current_input_masks : event_mask_mask; width_in_pixels : int; height_in_pixels : int; width_in_millimeters : int; height_in_millimeters : int; min_installed_maps : int; max_installed_maps : int; root_visual : visualid; backing_stores : backing_store_enum; save_unders : bool; root_depth : int; allowed_depths : depth list; };;
type setup_request = { byte_order : int; protocol_major_version : int; protocol_minor_version : int; authorization_protocol_name : char list; authorization_protocol_data : char list; };;
type setup_failed = { status : int; protocol_major_version : int; protocol_minor_version : int; length : int; reason : char list; };;
type setup_authenticate = { status : int; length : int; reason : char list; };;
type image_order_enum = Lsb_first | Msb_first;;
type setup = { status : int; protocol_major_version : int; protocol_minor_version : int; length : int; release_number : int32; resource_id_base : int32; resource_id_mask : int32; motion_buffer_size : int32; maximum_request_length : int; image_byte_order : image_order_enum; bitmap_format_bit_order : image_order_enum; bitmap_format_scanline_unit : int; bitmap_format_scanline_pad : int; min_keycode : keycode; max_keycode : keycode; vendor : char list; pixmap_formats : format list; roots : screen list; };;
type mod_mask_mask = [ `Shift | `Lock | `Control | `D1 | `D2 | `D3 | `D4 | `D5 | `Any ] list;;
type key_but_mask_mask = [ `Shift | `Lock | `Control | `Mod1 | `Mod2 | `Mod3 | `Mod4 | `Mod5 | `Button1 | `Button2 | `Button3 | `Button4 | `Button5 ] list;;
type window_enum = None;;
type key_press_event = { detail : keycode; time : timestamp; root : window; event : window; child : (window_enum, window) alt; root_x : int; root_y : int; event_x : int; event_y : int; state : key_but_mask_mask; same_screen : bool; };;
type key_release_event = key_press_event;;
type button_mask_mask = [ `D1 | `D2 | `D3 | `D4 | `D5 | `Any ] list;;
type button_press_event = { detail : button; time : timestamp; root : window; event : window; child : (window_enum, window) alt; root_x : int; root_y : int; event_x : int; event_y : int; state : key_but_mask_mask; same_screen : bool; };;
type button_release_event = button_press_event;;
type motion_enum = Normal | Hint;;
type motion_notify_event = { detail : motion_enum; time : timestamp; root : window; event : window; child : (window_enum, window) alt; root_x : int; root_y : int; event_x : int; event_y : int; state : key_but_mask_mask; same_screen : bool; };;
type notify_detail_enum = Ancestor | Virtual | Inferior | Nonlinear | Nonlinear_virtual | Pointer | Pointer_root | None;;
type notify_mode_enum = Normal | Grab | Ungrab | While_grabbed;;
type enter_notify_event = { detail : notify_detail_enum; time : timestamp; root : window; event : window; child : (window_enum, window) alt; root_x : int; root_y : int; event_x : int; event_y : int; state : key_but_mask_mask; mode : notify_mode_enum; same_screen_focus : char; };;
type leave_notify_event = enter_notify_event;;
type focus_in_event = { detail : notify_detail_enum; event : window; mode : notify_mode_enum; };;
type focus_out_event = focus_in_event;;
type keymap_notify_event = { keys : int list; };;
type expose_event = { window : window; x : int; y : int; width : int; height : int; count : int; };;
type graphics_exposure_event = { drawable : drawable; x : int; y : int; width : int; height : int; minor_opcode : int; count : int; major_opcode : int; };;
type no_exposure_event = { drawable : drawable; minor_opcode : int; major_opcode : int; };;
type visibility_enum = Unobscured | Partially_obscured | Fully_obscured;;
type visibility_notify_event = { window : window; state : visibility_enum; };;
type create_notify_event = { parent : window; window : window; x : int; y : int; width : int; height : int; border_width : int; override_redirect : bool; };;
type destroy_notify_event = { event : window; window : window; };;
type unmap_notify_event = { event : window; window : window; from_configure : bool; };;
type map_notify_event = { event : window; window : window; override_redirect : bool; };;
type map_request_event = { parent : window; window : window; };;
type reparent_notify_event = { event : window; window : window; parent : window; x : int; y : int; override_redirect : bool; };;
type configure_notify_event = { event : window; window : window; above_sibling : (window_enum, window) alt; x : int; y : int; width : int; height : int; border_width : int; override_redirect : bool; };;
type stack_mode_enum = Above | Below | Top_if | Bottom_if | Opposite;;
type config_window_mask = [ `X | `Y | `Width | `Height | `Border_width | `Sibling | `Stack_mode ] list;;
type configure_request_event = { stack_mode : stack_mode_enum; parent : window; window : window; sibling : (window_enum, window) alt; x : int; y : int; width : int; height : int; border_width : int; value_mask : config_window_mask; };;
type gravity_notify_event = { event : window; window : window; x : int; y : int; };;
type resize_request_event = { window : window; width : int; height : int; };;
type place_enum = On_top | On_bottom;;
type circulate_notify_event = { event : window; window : window; place : place_enum; };;
type circulate_request_event = circulate_notify_event;;
type property_enum = New_value | Delete;;
type property_notify_event = { window : window; atom : atom; time : timestamp; state : property_enum; };;
type selection_clear_event = { time : timestamp; owner : window; selection : atom; };;
type time_enum = Current_time;;
type atom_enum = None | Any | Primary | Secondary | Arc | Atom | Bitmap | Cardinal | Colormap | Cursor | Cut_buffer0 | Cut_buffer1 | Cut_buffer2 | Cut_buffer3 | Cut_buffer4 | Cut_buffer5 | Cut_buffer6 | Cut_buffer7 | Drawable | Font | Integer | Pixmap | Point | Rectangle | Resource_manager | Rgb_color_map | Rgb_best_map | Rgb_blue_map | Rgb_default_map | Rgb_gray_map | Rgb_green_map | Rgb_red_map | String | Visualid | Window | Wm_command | Wm_hints | Wm_client_machine | Wm_icon_name | Wm_icon_size | Wm_name | Wm_normal_hints | Wm_size_hints | Wm_zoom_hints | Min_space | Norm_space | Max_space | End_space | Superscript_x | Superscript_y | Subscript_x | Subscript_y | Underline_position | Underline_thickness | Strikeout_ascent | Strikeout_descent | Italic_angle | X_height | Quad_width | Weight | Point_size | Resolution | Copyright | Notice | Font_name | Family_name | Full_name | Cap_height | Wm_class | Wm_transient_for;;
type selection_request_event = { time : (time_enum, timestamp) alt; owner : window; requestor : window; selection : atom; target : atom; property : (atom_enum, atom) alt; };;
type selection_notify_event = { time : (time_enum, timestamp) alt; requestor : window; selection : atom; target : atom; property : (atom_enum, atom) alt; };;
type colormap_state_enum = Uninstalled | Installed;;
type colormap_enum = None;;
type colormap_notify_event = { window : window; colormap : (colormap_enum, colormap) alt; new_ : bool; state : colormap_state_enum; };;
type client_message_data_format_enum = Data8 | Data16 | Data32;;
type client_message_data_format_variant = Data8 of { data8 : int list; } | Data16 of { data16 : int list; } | Data32 of { data32 : int32 list; };;
type client_message_event = { window : window; type_ : atom; data : client_message_data_format_variant; };;
type mapping_enum = Modifier | Keyboard | Pointer;;
type mapping_notify_event = { request : mapping_enum; first_keycode : keycode; count : int; };;
type ge_generic_event = unit;;
type request_error = { bad_value : int32; minor_opcode : int; major_opcode : int; };;
type value_error = { bad_value : int32; minor_opcode : int; major_opcode : int; };;
type window_error = value_error;;
type pixmap_error = value_error;;
type atom_error = value_error;;
type cursor_error = value_error;;
type font_error = value_error;;
type match_error = request_error;;
type drawable_error = value_error;;
type access_error = request_error;;
type alloc_error = request_error;;
type colormap_error = value_error;;
type g_context_error = value_error;;
type id_choice_error = value_error;;
type name_error = request_error;;
type length_error = request_error;;
type implementation_error = request_error;;
type window_class_enum = Copy_from_parent | Input_output | Input_only;;
type cw_mask = [ `Back_pixmap | `Back_pixel | `Border_pixmap | `Border_pixel | `Bit_gravity | `Win_gravity | `Backing_store | `Backing_planes | `Backing_pixel | `Override_redirect | `Save_under | `Event_mask | `Dont_propagate | `Colormap | `Cursor ] list;;
type back_pixmap_enum = None | Parent_relative;;
type gravity_enum = Bit_forget | Win_unmap | North_west | North | North_east | West | Center | East | South_west | South | South_east | Static;;
type pixmap_enum = None;;
type cursor_enum = None;;
let create_window ~(depth : int) ~(wid : window) ~(parent : window) ~(x : int) ~(y : int) ~(width : int) ~(height : int) ~(border_width : int) ~(class_ : window_class_enum) ~(visual : visualid) ?(background_pixmap : (back_pixmap_enum, pixmap) alt option) ?(background_pixel : int32 option) ?(border_pixmap : (pixmap_enum, pixmap) alt option) ?(border_pixel : int32 option) ?(bit_gravity : gravity_enum option) ?(win_gravity : gravity_enum option) ?(backing_store : backing_store_enum option) ?(backing_planes : int32 option) ?(backing_pixel : int32 option) ?(override_redirect : bool32 option) ?(save_under : bool32 option) ?(event_mask : event_mask_mask option) ?(do_not_propogate_mask : event_mask_mask option) ?(colormap : (colormap_enum, colormap) alt option) ?(cursor : (cursor_enum, cursor) alt option) () : unit Lwt.t = failwith "not implemented";;
let change_window_attributes ~(window : window) ?(background_pixmap : (back_pixmap_enum, pixmap) alt option) ?(background_pixel : int32 option) ?(border_pixmap : (pixmap_enum, pixmap) alt option) ?(border_pixel : int32 option) ?(bit_gravity : gravity_enum option) ?(win_gravity : gravity_enum option) ?(backing_store : backing_store_enum option) ?(backing_planes : int32 option) ?(backing_pixel : int32 option) ?(override_redirect : bool32 option) ?(save_under : bool32 option) ?(event_mask : event_mask_mask option) ?(do_not_propogate_mask : event_mask_mask option) ?(colormap : (colormap_enum, colormap) alt option) ?(cursor : (cursor_enum, cursor) alt option) () : unit Lwt.t = failwith "not implemented";;
type map_state_enum = Unmapped | Unviewable | Viewable;;
type get_window_attributes_reply = { backing_store : backing_store_enum; visual : visualid; class_ : window_class_enum; bit_gravity : gravity_enum; win_gravity : gravity_enum; backing_planes : int32; backing_pixel : int32; save_under : bool; map_is_installed : bool; map_state : map_state_enum; override_redirect : bool; colormap : (colormap_enum, colormap) alt; all_event_masks : event_mask_mask; your_event_mask : event_mask_mask; do_not_propagate_mask : event_mask_mask; };;
let get_window_attributes ~(window : window) () : get_window_attributes_reply Lwt.t = failwith "not implemented";;
let destroy_window ~(window : window) () : unit Lwt.t = failwith "not implemented";;
let destroy_subwindows ~(window : window) () : unit Lwt.t = failwith "not implemented";;
type set_mode_enum = Insert | Delete;;
let change_save_set ~(mode : set_mode_enum) ~(window : window) () : unit Lwt.t = failwith "not implemented";;
let reparent_window ~(window : window) ~(parent : window) ~(x : int) ~(y : int) () : unit Lwt.t = failwith "not implemented";;
let map_window ~(window : window) () : unit Lwt.t = failwith "not implemented";;
let map_subwindows ~(window : window) () : unit Lwt.t = failwith "not implemented";;
let unmap_window ~(window : window) () : unit Lwt.t = failwith "not implemented";;
let unmap_subwindows ~(window : window) () : unit Lwt.t = failwith "not implemented";;
let configure_window ~(window : window) ?(x : int32 option) ?(y : int32 option) ?(width : int32 option) ?(height : int32 option) ?(border_width : int32 option) ?(sibling : (window_enum, window) alt option) ?(stack_mode : stack_mode_enum option) () : unit Lwt.t = failwith "not implemented";;
type circulate_enum = Raise_lowest | Lower_highest;;
let circulate_window ~(direction : circulate_enum) ~(window : window) () : unit Lwt.t = failwith "not implemented";;
type get_geometry_reply = { depth : int; root : window; x : int; y : int; width : int; height : int; border_width : int; };;
let get_geometry ~(drawable : drawable) () : get_geometry_reply Lwt.t = failwith "not implemented";;
type query_tree_reply = { root : window; parent : (window_enum, window) alt; children : window list; };;
let query_tree ~(window : window) () : query_tree_reply Lwt.t = failwith "not implemented";;
type intern_atom_reply = { atom : (atom_enum, atom) alt; };;
let intern_atom ~(only_if_exists : bool) ~(name : char list) () : intern_atom_reply Lwt.t = failwith "not implemented";;
type get_atom_name_reply = { name : char list; };;
let get_atom_name ~(atom : atom) () : get_atom_name_reply Lwt.t = failwith "not implemented";;
type prop_mode_enum = Replace | Prepend | Append;;
let change_property ~(mode : prop_mode_enum) ~(window : window) ~(property : atom) ~(type_ : atom) ~(format : int) ~(data_len : int32) ~(data : char list) () : unit Lwt.t = failwith "not implemented";;
let delete_property ~(window : window) ~(property : atom) () : unit Lwt.t = failwith "not implemented";;
type get_property_type_enum = Any;;
type get_property_reply = { format : int; type_ : atom; bytes_after : int32; value_len : int32; value : char list; };;
let get_property ~(delete : bool) ~(window : window) ~(property : atom) ~(type_ : (get_property_type_enum, atom) alt) ~(long_offset : int32) ~(long_length : int32) () : get_property_reply Lwt.t = failwith "not implemented";;
type list_properties_reply = { atoms : atom list; };;
let list_properties ~(window : window) () : list_properties_reply Lwt.t = failwith "not implemented";;
let set_selection_owner ~(owner : (window_enum, window) alt) ~(selection : atom) ~(time : (time_enum, timestamp) alt) () : unit Lwt.t = failwith "not implemented";;
type get_selection_owner_reply = { owner : (window_enum, window) alt; };;
let get_selection_owner ~(selection : atom) () : get_selection_owner_reply Lwt.t = failwith "not implemented";;
let convert_selection ~(requestor : window) ~(selection : atom) ~(target : atom) ~(property : (atom_enum, atom) alt) ~(time : (time_enum, timestamp) alt) () : unit Lwt.t = failwith "not implemented";;
type send_event_dest_enum = Pointer_window | Item_focus;;
let send_event ~(propagate : bool) ~(destination : (send_event_dest_enum, window) alt) ~(event_mask : event_mask_mask) ~(event : char list) () : unit Lwt.t = failwith "not implemented";;
type grab_mode_enum = Sync | Async;;
type grab_status_enum = Success | Already_grabbed | Invalid_time | Not_viewable | Frozen;;
type grab_pointer_reply = { status : grab_status_enum; };;
let grab_pointer ~(owner_events : bool) ~(grab_window : window) ~(event_mask : event_mask_mask) ~(pointer_mode : grab_mode_enum) ~(keyboard_mode : grab_mode_enum) ~(confine_to : (window_enum, window) alt) ~(cursor : (cursor_enum, cursor) alt) ~(time : (time_enum, timestamp) alt) () : grab_pointer_reply Lwt.t = failwith "not implemented";;
let ungrab_pointer ~(time : (time_enum, timestamp) alt) () : unit Lwt.t = failwith "not implemented";;
type button_index_enum = Any | D1 | D2 | D3 | D4 | D5;;
let grab_button ~(owner_events : bool) ~(grab_window : window) ~(event_mask : event_mask_mask) ~(pointer_mode : grab_mode_enum) ~(keyboard_mode : grab_mode_enum) ~(confine_to : (window_enum, window) alt) ~(cursor : (cursor_enum, cursor) alt) ~(button : button_index_enum) ~(modifiers : mod_mask_mask) () : unit Lwt.t = failwith "not implemented";;
let ungrab_button ~(button : button_index_enum) ~(grab_window : window) ~(modifiers : mod_mask_mask) () : unit Lwt.t = failwith "not implemented";;
let change_active_pointer_grab ~(cursor : (cursor_enum, cursor) alt) ~(time : (time_enum, timestamp) alt) ~(event_mask : event_mask_mask) () : unit Lwt.t = failwith "not implemented";;
type grab_keyboard_reply = { status : grab_status_enum; };;
let grab_keyboard ~(owner_events : bool) ~(grab_window : window) ~(time : (time_enum, timestamp) alt) ~(pointer_mode : grab_mode_enum) ~(keyboard_mode : grab_mode_enum) () : grab_keyboard_reply Lwt.t = failwith "not implemented";;
let ungrab_keyboard ~(time : (time_enum, timestamp) alt) () : unit Lwt.t = failwith "not implemented";;
type grab_enum = Any;;
let grab_key ~(owner_events : bool) ~(grab_window : window) ~(modifiers : mod_mask_mask) ~(key : (grab_enum, keycode) alt) ~(pointer_mode : grab_mode_enum) ~(keyboard_mode : grab_mode_enum) () : unit Lwt.t = failwith "not implemented";;
let ungrab_key ~(key : (grab_enum, keycode) alt) ~(grab_window : window) ~(modifiers : mod_mask_mask) () : unit Lwt.t = failwith "not implemented";;
type allow_enum = Async_pointer | Sync_pointer | Replay_pointer | Async_keyboard | Sync_keyboard | Replay_keyboard | Async_both | Sync_both;;
let allow_events ~(mode : allow_enum) ~(time : (time_enum, timestamp) alt) () : unit Lwt.t = failwith "not implemented";;
let grab_server () : unit Lwt.t = failwith "not implemented";;
let ungrab_server () : unit Lwt.t = failwith "not implemented";;
type query_pointer_reply = { same_screen : bool; root : window; child : (window_enum, window) alt; root_x : int; root_y : int; win_x : int; win_y : int; mask : key_but_mask_mask; };;
let query_pointer ~(window : window) () : query_pointer_reply Lwt.t = failwith "not implemented";;
type timecoord = { time : timestamp; x : int; y : int; };;
type get_motion_events_reply = { events : timecoord list; };;
let get_motion_events ~(window : window) ~(start : (time_enum, timestamp) alt) ~(stop : (time_enum, timestamp) alt) () : get_motion_events_reply Lwt.t = failwith "not implemented";;
type translate_coordinates_reply = { same_screen : bool; child : (window_enum, window) alt; dst_x : int; dst_y : int; };;
let translate_coordinates ~(src_window : window) ~(dst_window : window) ~(src_x : int) ~(src_y : int) () : translate_coordinates_reply Lwt.t = failwith "not implemented";;
let warp_pointer ~(src_window : (window_enum, window) alt) ~(dst_window : (window_enum, window) alt) ~(src_x : int) ~(src_y : int) ~(src_width : int) ~(src_height : int) ~(dst_x : int) ~(dst_y : int) () : unit Lwt.t = failwith "not implemented";;
type input_focus_enum = None | Pointer_root | Parent | Follow_keyboard;;
let set_input_focus ~(revert_to : input_focus_enum) ~(focus : (input_focus_enum, window) alt) ~(time : (time_enum, timestamp) alt) () : unit Lwt.t = failwith "not implemented";;
type get_input_focus_reply = { revert_to : input_focus_enum; focus : (input_focus_enum, window) alt; };;
let get_input_focus () : get_input_focus_reply Lwt.t = failwith "not implemented";;
type query_keymap_reply = { keys : int list; };;
let query_keymap () : query_keymap_reply Lwt.t = failwith "not implemented";;
let open_font ~(fid : font) ~(name : char list) () : unit Lwt.t = failwith "not implemented";;
let close_font ~(font : font) () : unit Lwt.t = failwith "not implemented";;
type font_draw_enum = Left_to_right | Right_to_left;;
type fontprop = { name : atom; value : int32; };;
type charinfo = { left_side_bearing : int; right_side_bearing : int; character_width : int; ascent : int; descent : int; attributes : int; };;
type query_font_reply = { min_bounds : charinfo; max_bounds : charinfo; min_char_or_byte2 : int; max_char_or_byte2 : int; default_char : int; draw_direction : font_draw_enum; min_byte1 : int; max_byte1 : int; all_chars_exist : bool; font_ascent : int; font_descent : int; properties : fontprop list; char_infos : charinfo list; };;
let query_font ~(font : fontable) () : query_font_reply Lwt.t = failwith "not implemented";;
type query_text_extents_reply = { draw_direction : font_draw_enum; font_ascent : int; font_descent : int; overall_ascent : int; overall_descent : int; overall_width : int32; overall_left : int32; overall_right : int32; };;
let query_text_extents ~(odd_length : bool) ~(font : fontable) ~(string : char2b list) () : query_text_extents_reply Lwt.t = failwith "not implemented";;
type str = { name : char list; };;
type list_fonts_reply = { names : str list; };;
let list_fonts ~(max_names : int) ~(pattern : char list) () : list_fonts_reply Lwt.t = failwith "not implemented";;
type list_fonts_with_info_reply = { min_bounds : charinfo; max_bounds : charinfo; min_char_or_byte2 : int; max_char_or_byte2 : int; default_char : int; draw_direction : font_draw_enum; min_byte1 : int; max_byte1 : int; all_chars_exist : bool; font_ascent : int; font_descent : int; replies_hint : int32; properties : fontprop list; name : char list; };;
let list_fonts_with_info ~(max_names : int) ~(pattern : char list) () : list_fonts_with_info_reply Lwt.t = failwith "not implemented";;
let set_font_path ~(font : str list) () : unit Lwt.t = failwith "not implemented";;
type get_font_path_reply = { path : str list; };;
let get_font_path () : get_font_path_reply Lwt.t = failwith "not implemented";;
let create_pixmap ~(depth : int) ~(pid : pixmap) ~(drawable : drawable) ~(width : int) ~(height : int) () : unit Lwt.t = failwith "not implemented";;
let free_pixmap ~(pixmap : pixmap) () : unit Lwt.t = failwith "not implemented";;
type gc_mask = [ `Function | `Plane_mask | `Foreground | `Background | `Line_width | `Line_style | `Cap_style | `Join_style | `Fill_style | `Fill_rule | `Tile | `Stipple | `Tile_stipple_origin_x | `Tile_stipple_origin_y | `Font | `Subwindow_mode | `Graphics_exposures | `Clip_origin_x | `Clip_origin_y | `Clip_mask | `Dash_offset | `Dash_list | `Arc_mode ] list;;
type gx_enum = Clear | And | And_reverse | Copy | And_inverted | Noop | Xor | Or | Nor | Equiv | Invert | Or_reverse | Copy_inverted | Or_inverted | Nand | Set;;
type line_style_enum = Solid | On_off_dash | Double_dash;;
type cap_style_enum = Not_last | Butt | Round | Projecting;;
type join_style_enum = Miter | Round | Bevel;;
type fill_style_enum = Solid | Tiled | Stippled | Opaque_stippled;;
type fill_rule_enum = Even_odd | Winding;;
type subwindow_mode_enum = Clip_by_children | Include_inferiors;;
type arc_mode_enum = Chord | Pie_slice;;
type font_enum = None;;
let create_gc ~(cid : gcontext) ~(drawable : drawable) ?(function_ : gx_enum option) ?(plane_mask : int32 option) ?(foreground : int32 option) ?(background : int32 option) ?(line_width : int32 option) ?(line_style : line_style_enum option) ?(cap_style : cap_style_enum option) ?(join_style : join_style_enum option) ?(fill_style : fill_style_enum option) ?(fill_rule : fill_rule_enum option) ?(tile : (pixmap_enum, pixmap) alt option) ?(stipple : (pixmap_enum, pixmap) alt option) ?(tile_stipple_x_origin : int32 option) ?(tile_stipple_y_origin : int32 option) ?(font : (font_enum, font) alt option) ?(subwindow_mode : subwindow_mode_enum option) ?(graphics_exposures : bool32 option) ?(clip_x_origin : int32 option) ?(clip_y_origin : int32 option) ?(clip_mask : (pixmap_enum, pixmap) alt option) ?(dash_offset : int32 option) ?(dashes : int32 option) ?(arc_mode : arc_mode_enum option) () : unit Lwt.t = failwith "not implemented";;
let change_gc ~(gc : gcontext) ?(function_ : gx_enum option) ?(plane_mask : int32 option) ?(foreground : int32 option) ?(background : int32 option) ?(line_width : int32 option) ?(line_style : line_style_enum option) ?(cap_style : cap_style_enum option) ?(join_style : join_style_enum option) ?(fill_style : fill_style_enum option) ?(fill_rule : fill_rule_enum option) ?(tile : (pixmap_enum, pixmap) alt option) ?(stipple : (pixmap_enum, pixmap) alt option) ?(tile_stipple_x_origin : int32 option) ?(tile_stipple_y_origin : int32 option) ?(font : (font_enum, font) alt option) ?(subwindow_mode : subwindow_mode_enum option) ?(graphics_exposures : bool32 option) ?(clip_x_origin : int32 option) ?(clip_y_origin : int32 option) ?(clip_mask : (pixmap_enum, pixmap) alt option) ?(dash_offset : int32 option) ?(dashes : int32 option) ?(arc_mode : arc_mode_enum option) () : unit Lwt.t = failwith "not implemented";;
let copy_gc ~(src_gc : gcontext) ~(dst_gc : gcontext) ~(value_mask : gc_mask) () : unit Lwt.t = failwith "not implemented";;
let set_dashes ~(gc : gcontext) ~(dash_offset : int) ~(dashes : int list) () : unit Lwt.t = failwith "not implemented";;
type clip_ordering_enum = Unsorted | Y_sorted | Yx_sorted | Yx_banded;;
let set_clip_rectangles ~(ordering : clip_ordering_enum) ~(gc : gcontext) ~(clip_x_origin : int) ~(clip_y_origin : int) ~(rectangles : rectangle list) () : unit Lwt.t = failwith "not implemented";;
let free_gc ~(gc : gcontext) () : unit Lwt.t = failwith "not implemented";;
let clear_area ~(exposures : bool) ~(window : window) ~(x : int) ~(y : int) ~(width : int) ~(height : int) () : unit Lwt.t = failwith "not implemented";;
let copy_area ~(src_drawable : drawable) ~(dst_drawable : drawable) ~(gc : gcontext) ~(src_x : int) ~(src_y : int) ~(dst_x : int) ~(dst_y : int) ~(width : int) ~(height : int) () : unit Lwt.t = failwith "not implemented";;
let copy_plane ~(src_drawable : drawable) ~(dst_drawable : drawable) ~(gc : gcontext) ~(src_x : int) ~(src_y : int) ~(dst_x : int) ~(dst_y : int) ~(width : int) ~(height : int) ~(bit_plane : int32) () : unit Lwt.t = failwith "not implemented";;
type coord_mode_enum = Origin | Previous;;
let poly_point ~(coordinate_mode : coord_mode_enum) ~(drawable : drawable) ~(gc : gcontext) ~(points : point list) () : unit Lwt.t = failwith "not implemented";;
let poly_line ~(coordinate_mode : coord_mode_enum) ~(drawable : drawable) ~(gc : gcontext) ~(points : point list) () : unit Lwt.t = failwith "not implemented";;
type segment = { x1 : int; y1 : int; x2 : int; y2 : int; };;
let poly_segment ~(drawable : drawable) ~(gc : gcontext) ~(segments : segment list) () : unit Lwt.t = failwith "not implemented";;
let poly_rectangle ~(drawable : drawable) ~(gc : gcontext) ~(rectangles : rectangle list) () : unit Lwt.t = failwith "not implemented";;
let poly_arc ~(drawable : drawable) ~(gc : gcontext) ~(arcs : arc list) () : unit Lwt.t = failwith "not implemented";;
type poly_shape_enum = Complex | Nonconvex | Convex;;
let fill_poly ~(drawable : drawable) ~(gc : gcontext) ~(shape : poly_shape_enum) ~(coordinate_mode : coord_mode_enum) ~(points : point list) () : unit Lwt.t = failwith "not implemented";;
let poly_fill_rectangle ~(drawable : drawable) ~(gc : gcontext) ~(rectangles : rectangle list) () : unit Lwt.t = failwith "not implemented";;
let poly_fill_arc ~(drawable : drawable) ~(gc : gcontext) ~(arcs : arc list) () : unit Lwt.t = failwith "not implemented";;
type image_format_enum = Xy_bitmap | Xy_pixmap | Z_pixmap;;
let put_image ~(format : image_format_enum) ~(drawable : drawable) ~(gc : gcontext) ~(width : int) ~(height : int) ~(dst_x : int) ~(dst_y : int) ~(left_pad : int) ~(depth : int) ~(data : char list) () : unit Lwt.t = failwith "not implemented";;
type get_image_reply = { depth : int; visual : visualid; data : char list; };;
let get_image ~(format : image_format_enum) ~(drawable : drawable) ~(x : int) ~(y : int) ~(width : int) ~(height : int) ~(plane_mask : int32) () : get_image_reply Lwt.t = failwith "not implemented";;
let poly_text8 ~(drawable : drawable) ~(gc : gcontext) ~(x : int) ~(y : int) ~(items : char list) () : unit Lwt.t = failwith "not implemented";;
let poly_text16 ~(drawable : drawable) ~(gc : gcontext) ~(x : int) ~(y : int) ~(items : char list) () : unit Lwt.t = failwith "not implemented";;
let image_text8 ~(drawable : drawable) ~(gc : gcontext) ~(x : int) ~(y : int) ~(string : char list) () : unit Lwt.t = failwith "not implemented";;
let image_text16 ~(drawable : drawable) ~(gc : gcontext) ~(x : int) ~(y : int) ~(string : char2b list) () : unit Lwt.t = failwith "not implemented";;
type colormap_alloc_enum = None | All;;
let create_colormap ~(alloc : colormap_alloc_enum) ~(mid : colormap) ~(window : window) ~(visual : visualid) () : unit Lwt.t = failwith "not implemented";;
let free_colormap ~(cmap : colormap) () : unit Lwt.t = failwith "not implemented";;
let copy_colormap_and_free ~(mid : colormap) ~(src_cmap : colormap) () : unit Lwt.t = failwith "not implemented";;
let install_colormap ~(cmap : colormap) () : unit Lwt.t = failwith "not implemented";;
let uninstall_colormap ~(cmap : colormap) () : unit Lwt.t = failwith "not implemented";;
type list_installed_colormaps_reply = { cmaps : colormap list; };;
let list_installed_colormaps ~(window : window) () : list_installed_colormaps_reply Lwt.t = failwith "not implemented";;
type alloc_color_reply = { red : int; green : int; blue : int; pixel : int32; };;
let alloc_color ~(cmap : colormap) ~(red : int) ~(green : int) ~(blue : int) () : alloc_color_reply Lwt.t = failwith "not implemented";;
type alloc_named_color_reply = { pixel : int32; exact_red : int; exact_green : int; exact_blue : int; visual_red : int; visual_green : int; visual_blue : int; };;
let alloc_named_color ~(cmap : colormap) ~(name : char list) () : alloc_named_color_reply Lwt.t = failwith "not implemented";;
type alloc_color_cells_reply = { pixels : int32 list; masks : int32 list; };;
let alloc_color_cells ~(contiguous : bool) ~(cmap : colormap) ~(colors : int) ~(planes : int) () : alloc_color_cells_reply Lwt.t = failwith "not implemented";;
type alloc_color_planes_reply = { red_mask : int32; green_mask : int32; blue_mask : int32; pixels : int32 list; };;
let alloc_color_planes ~(contiguous : bool) ~(cmap : colormap) ~(colors : int) ~(reds : int) ~(greens : int) ~(blues : int) () : alloc_color_planes_reply Lwt.t = failwith "not implemented";;
let free_colors ~(cmap : colormap) ~(plane_mask : int32) ~(pixels : int32 list) () : unit Lwt.t = failwith "not implemented";;
type color_flag_mask = [ `Red | `Green | `Blue ] list;;
type coloritem = { pixel : int32; red : int; green : int; blue : int; flags : color_flag_mask; };;
let store_colors ~(cmap : colormap) ~(items : coloritem list) () : unit Lwt.t = failwith "not implemented";;
let store_named_color ~(flags : color_flag_mask) ~(cmap : colormap) ~(pixel : int32) ~(name : char list) () : unit Lwt.t = failwith "not implemented";;
type rgb = { red : int; green : int; blue : int; };;
type query_colors_reply = { colors : rgb list; };;
let query_colors ~(cmap : colormap) ~(pixels : int32 list) () : query_colors_reply Lwt.t = failwith "not implemented";;
type lookup_color_reply = { exact_red : int; exact_green : int; exact_blue : int; visual_red : int; visual_green : int; visual_blue : int; };;
let lookup_color ~(cmap : colormap) ~(name : char list) () : lookup_color_reply Lwt.t = failwith "not implemented";;
let create_cursor ~(cid : cursor) ~(source : pixmap) ~(mask : (pixmap_enum, pixmap) alt) ~(fore_red : int) ~(fore_green : int) ~(fore_blue : int) ~(back_red : int) ~(back_green : int) ~(back_blue : int) ~(x : int) ~(y : int) () : unit Lwt.t = failwith "not implemented";;
let create_glyph_cursor ~(cid : cursor) ~(source_font : font) ~(mask_font : (font_enum, font) alt) ~(source_char : int) ~(mask_char : int) ~(fore_red : int) ~(fore_green : int) ~(fore_blue : int) ~(back_red : int) ~(back_green : int) ~(back_blue : int) () : unit Lwt.t = failwith "not implemented";;
let free_cursor ~(cursor : cursor) () : unit Lwt.t = failwith "not implemented";;
let recolor_cursor ~(cursor : cursor) ~(fore_red : int) ~(fore_green : int) ~(fore_blue : int) ~(back_red : int) ~(back_green : int) ~(back_blue : int) () : unit Lwt.t = failwith "not implemented";;
type query_shape_of_enum = Largest_cursor | Fastest_tile | Fastest_stipple;;
type query_best_size_reply = { width : int; height : int; };;
let query_best_size ~(class_ : query_shape_of_enum) ~(drawable : drawable) ~(width : int) ~(height : int) () : query_best_size_reply Lwt.t = failwith "not implemented";;
type query_extension_reply = { present : bool; major_opcode : int; first_event : int; first_error : int; };;
let query_extension ~(name : char list) () : query_extension_reply Lwt.t = failwith "not implemented";;
type list_extensions_reply = { names : str list; };;
let list_extensions () : list_extensions_reply Lwt.t = failwith "not implemented";;
let change_keyboard_mapping ~(keycode_count : int) ~(first_keycode : keycode) ~(keysyms_per_keycode : int) ~(keysyms : keysym list) () : unit Lwt.t = failwith "not implemented";;
type get_keyboard_mapping_reply = { keysyms_per_keycode : char; keysyms : keysym list; };;
let get_keyboard_mapping ~(first_keycode : keycode) ~(count : int) () : get_keyboard_mapping_reply Lwt.t = failwith "not implemented";;
type kb_mask = [ `Key_click_percent | `Bell_percent | `Bell_pitch | `Bell_duration | `Led | `Led_mode | `Key | `Auto_repeat_mode ] list;;
type led_mode_enum = Off | On;;
type auto_repeat_mode_enum = Off | On | Default;;
let change_keyboard_control ?(key_click_percent : int32 option) ?(bell_percent : int32 option) ?(bell_pitch : int32 option) ?(bell_duration : int32 option) ?(led : int32 option) ?(led_mode : led_mode_enum option) ?(key : keycode32 option) ?(auto_repeat_mode : auto_repeat_mode_enum option) () : unit Lwt.t = failwith "not implemented";;
type get_keyboard_control_reply = { global_auto_repeat : auto_repeat_mode_enum; led_mask : int32; key_click_percent : int; bell_percent : int; bell_pitch : int; bell_duration : int; auto_repeats : int list; };;
let get_keyboard_control () : get_keyboard_control_reply Lwt.t = failwith "not implemented";;
let bell ~(percent : int) () : unit Lwt.t = failwith "not implemented";;
let change_pointer_control ~(acceleration_numerator : int) ~(acceleration_denominator : int) ~(threshold : int) ~(do_acceleration : bool) ~(do_threshold : bool) () : unit Lwt.t = failwith "not implemented";;
type get_pointer_control_reply = { acceleration_numerator : int; acceleration_denominator : int; threshold : int; };;
let get_pointer_control () : get_pointer_control_reply Lwt.t = failwith "not implemented";;
type blanking_enum = Not_preferred | Preferred | Default;;
type exposures_enum = Not_allowed | Allowed | Default;;
let set_screen_saver ~(timeout : int) ~(interval : int) ~(prefer_blanking : blanking_enum) ~(allow_exposures : exposures_enum) () : unit Lwt.t = failwith "not implemented";;
type get_screen_saver_reply = { timeout : int; interval : int; prefer_blanking : blanking_enum; allow_exposures : exposures_enum; };;
let get_screen_saver () : get_screen_saver_reply Lwt.t = failwith "not implemented";;
type host_mode_enum = Insert | Delete;;
type family_enum = Internet | Decnet | Chaos | Server_interpreted | Internet6;;
let change_hosts ~(mode : host_mode_enum) ~(family : family_enum) ~(address : char list) () : unit Lwt.t = failwith "not implemented";;
type host = { family : family_enum; address : char list; };;
type access_control_enum = Disable | Enable;;
type list_hosts_reply = { mode : access_control_enum; hosts : host list; };;
let list_hosts () : list_hosts_reply Lwt.t = failwith "not implemented";;
let set_access_control ~(mode : access_control_enum) () : unit Lwt.t = failwith "not implemented";;
type close_down_enum = Destroy_all | Retain_permanent | Retain_temporary;;
let set_close_down_mode ~(mode : close_down_enum) () : unit Lwt.t = failwith "not implemented";;
type kill_enum = All_temporary;;
let kill_client ~(resource : (kill_enum, int32) alt) () : unit Lwt.t = failwith "not implemented";;
let rotate_properties ~(window : window) ~(delta : int) ~(atoms : atom list) () : unit Lwt.t = failwith "not implemented";;
type screen_saver_enum = Reset | Active;;
let force_screen_saver ~(mode : screen_saver_enum) () : unit Lwt.t = failwith "not implemented";;
type mapping_status_enum = Success | Busy | Failure;;
type set_pointer_mapping_reply = { status : mapping_status_enum; };;
let set_pointer_mapping ~(map : int list) () : set_pointer_mapping_reply Lwt.t = failwith "not implemented";;
type get_pointer_mapping_reply = { map : int list; };;
let get_pointer_mapping () : get_pointer_mapping_reply Lwt.t = failwith "not implemented";;
type map_index_enum = Shift | Lock | Control | D1 | D2 | D3 | D4 | D5;;
type set_modifier_mapping_reply = { status : mapping_status_enum; };;
let set_modifier_mapping ~(keycodes_per_modifier : int) ~(keycodes : keycode list) () : set_modifier_mapping_reply Lwt.t = failwith "not implemented";;
type get_modifier_mapping_reply = { keycodes_per_modifier : int; keycodes : keycode list; };;
let get_modifier_mapping () : get_modifier_mapping_reply Lwt.t = failwith "not implemented";;
let no_operation () : unit Lwt.t = failwith "not implemented";;
end
module[@warning "-27"] Render = struct
type pict_type_enum = Indexed | Direct;;
type picture_enum = None;;
type pict_op_enum = Clear | Src | Dst | Over | Over_reverse | In | In_reverse | Out | Out_reverse | Atop | Atop_reverse | Xor | Add | Saturate | Disjoint_clear | Disjoint_src | Disjoint_dst | Disjoint_over | Disjoint_over_reverse | Disjoint_in | Disjoint_in_reverse | Disjoint_out | Disjoint_out_reverse | Disjoint_atop | Disjoint_atop_reverse | Disjoint_xor | Conjoint_clear | Conjoint_src | Conjoint_dst | Conjoint_over | Conjoint_over_reverse | Conjoint_in | Conjoint_in_reverse | Conjoint_out | Conjoint_out_reverse | Conjoint_atop | Conjoint_atop_reverse | Conjoint_xor | Multiply | Screen | Overlay | Darken | Lighten | Color_dodge | Color_burn | Hard_light | Soft_light | Difference | Exclusion | Hsl_hue | Hsl_saturation | Hsl_color | Hsl_luminosity;;
type poly_edge_enum = Sharp | Smooth;;
type poly_mode_enum = Precise | Imprecise;;
type cp_mask = [ `Repeat | `Alpha_map | `Alpha_x_origin | `Alpha_y_origin | `Clip_x_origin | `Clip_y_origin | `Clip_mask | `Graphics_exposure | `Subwindow_mode | `Poly_edge | `Poly_mode | `Dither | `Component_alpha ] list;;
type sub_pixel_enum = Unknown | Horizontal_rgb | Horizontal_bgr | Vertical_rgb | Vertical_bgr | None;;
type repeat_enum = None | Normal | Pad | Reflect;;
type glyph = int32;;
type glyphset = xid;;
type picture = xid;;
type pictformat = xid;;
type fixed = int32;;
type pict_format_error = unit;;
type picture_error = unit;;
type pict_op_error = unit;;
type glyph_set_error = unit;;
type glyph_error = unit;;
type directformat = { red_shift : int; red_mask : int; green_shift : int; green_mask : int; blue_shift : int; blue_mask : int; alpha_shift : int; alpha_mask : int; };;
type pictforminfo = { id : pictformat; type_ : pict_type_enum; depth : int; direct : directformat; colormap : Xproto.colormap; };;
type pictvisual = { visual : Xproto.visualid; format : pictformat; };;
type pictdepth = { depth : int; visuals : pictvisual list; };;
type pictscreen = { fallback : pictformat; depths : pictdepth list; };;
type indexvalue = { pixel : int32; red : int; green : int; blue : int; alpha : int; };;
type color = { red : int; green : int; blue : int; alpha : int; };;
type pointfix = { x : fixed; y : fixed; };;
type linefix = { p1 : pointfix; p2 : pointfix; };;
type triangle = { p1 : pointfix; p2 : pointfix; p3 : pointfix; };;
type trapezoid = { top : fixed; bottom : fixed; left : linefix; right : linefix; };;
type glyphinfo = { width : int; height : int; x : int; y : int; x_off : int; y_off : int; };;
type query_version_reply = { major_version : int32; minor_version : int32; };;
let query_version ~(client_major_version : int32) ~(client_minor_version : int32) () : query_version_reply Lwt.t = failwith "not implemented";;
type query_pict_formats_reply = { num_depths : int32; num_visuals : int32; formats : pictforminfo list; screens : pictscreen list; subpixels : sub_pixel_enum list; };;
let query_pict_formats () : query_pict_formats_reply Lwt.t = failwith "not implemented";;
type query_pict_index_values_reply = { values : indexvalue list; };;
let query_pict_index_values ~(format : pictformat) () : query_pict_index_values_reply Lwt.t = failwith "not implemented";;
let create_picture ~(pid : picture) ~(drawable : Xproto.drawable) ~(format : pictformat) ?(repeat : repeat_enum option) ?(alphamap : picture option) ?(alphaxorigin : int32 option) ?(alphayorigin : int32 option) ?(clipxorigin : int32 option) ?(clipyorigin : int32 option) ?(clipmask : Xproto.pixmap option) ?(graphicsexposure : int32 option) ?(subwindowmode : Xproto.subwindow_mode_enum option) ?(polyedge : poly_edge_enum option) ?(polymode : poly_mode_enum option) ?(dither : Xproto.atom option) ?(componentalpha : int32 option) () : unit Lwt.t = failwith "not implemented";;
let change_picture ~(picture : picture) ?(repeat : repeat_enum option) ?(alphamap : picture option) ?(alphaxorigin : int32 option) ?(alphayorigin : int32 option) ?(clipxorigin : int32 option) ?(clipyorigin : int32 option) ?(clipmask : Xproto.pixmap option) ?(graphicsexposure : int32 option) ?(subwindowmode : Xproto.subwindow_mode_enum option) ?(polyedge : poly_edge_enum option) ?(polymode : poly_mode_enum option) ?(dither : Xproto.atom option) ?(componentalpha : int32 option) () : unit Lwt.t = failwith "not implemented";;
let set_picture_clip_rectangles ~(picture : picture) ~(clip_x_origin : int) ~(clip_y_origin : int) ~(rectangles : Xproto.rectangle list) () : unit Lwt.t = failwith "not implemented";;
let free_picture ~(picture : picture) () : unit Lwt.t = failwith "not implemented";;
let composite ~(op : pict_op_enum) ~(src : picture) ~(mask : (picture_enum, picture) alt) ~(dst : picture) ~(src_x : int) ~(src_y : int) ~(mask_x : int) ~(mask_y : int) ~(dst_x : int) ~(dst_y : int) ~(width : int) ~(height : int) () : unit Lwt.t = failwith "not implemented";;
let trapezoids ~(op : pict_op_enum) ~(src : picture) ~(dst : picture) ~(mask_format : pictformat) ~(src_x : int) ~(src_y : int) ~(traps : trapezoid list) () : unit Lwt.t = failwith "not implemented";;
let triangles ~(op : pict_op_enum) ~(src : picture) ~(dst : picture) ~(mask_format : pictformat) ~(src_x : int) ~(src_y : int) ~(triangles : triangle list) () : unit Lwt.t = failwith "not implemented";;
let tri_strip ~(op : pict_op_enum) ~(src : picture) ~(dst : picture) ~(mask_format : pictformat) ~(src_x : int) ~(src_y : int) ~(points : pointfix list) () : unit Lwt.t = failwith "not implemented";;
let tri_fan ~(op : pict_op_enum) ~(src : picture) ~(dst : picture) ~(mask_format : pictformat) ~(src_x : int) ~(src_y : int) ~(points : pointfix list) () : unit Lwt.t = failwith "not implemented";;
let create_glyph_set ~(gsid : glyphset) ~(format : pictformat) () : unit Lwt.t = failwith "not implemented";;
let reference_glyph_set ~(gsid : glyphset) ~(existing : glyphset) () : unit Lwt.t = failwith "not implemented";;
let free_glyph_set ~(glyphset : glyphset) () : unit Lwt.t = failwith "not implemented";;
let add_glyphs ~(glyphset : glyphset) ~(glyphids : int32 list) ~(glyphs : glyphinfo list) ~(data : char list) () : unit Lwt.t = failwith "not implemented";;
let free_glyphs ~(glyphset : glyphset) ~(glyphs : glyph list) () : unit Lwt.t = failwith "not implemented";;
let composite_glyphs8 ~(op : pict_op_enum) ~(src : picture) ~(dst : picture) ~(mask_format : pictformat) ~(glyphset : glyphset) ~(src_x : int) ~(src_y : int) ~(glyphcmds : char list) () : unit Lwt.t = failwith "not implemented";;
let composite_glyphs16 ~(op : pict_op_enum) ~(src : picture) ~(dst : picture) ~(mask_format : pictformat) ~(glyphset : glyphset) ~(src_x : int) ~(src_y : int) ~(glyphcmds : char list) () : unit Lwt.t = failwith "not implemented";;
let composite_glyphs32 ~(op : pict_op_enum) ~(src : picture) ~(dst : picture) ~(mask_format : pictformat) ~(glyphset : glyphset) ~(src_x : int) ~(src_y : int) ~(glyphcmds : char list) () : unit Lwt.t = failwith "not implemented";;
let fill_rectangles ~(op : pict_op_enum) ~(dst : picture) ~(color : color) ~(rects : Xproto.rectangle list) () : unit Lwt.t = failwith "not implemented";;
let create_cursor ~(cid : Xproto.cursor) ~(source : picture) ~(x : int) ~(y : int) () : unit Lwt.t = failwith "not implemented";;
type transform = { matrix11 : fixed; matrix12 : fixed; matrix13 : fixed; matrix21 : fixed; matrix22 : fixed; matrix23 : fixed; matrix31 : fixed; matrix32 : fixed; matrix33 : fixed; };;
let set_picture_transform ~(picture : picture) ~(transform : transform) () : unit Lwt.t = failwith "not implemented";;
type query_filters_reply = { aliases : int list; filters : Xproto.str list; };;
let query_filters ~(drawable : Xproto.drawable) () : query_filters_reply Lwt.t = failwith "not implemented";;
let set_picture_filter ~(picture : picture) ~(filter : char list) ~(values : fixed list) () : unit Lwt.t = failwith "not implemented";;
type animcursorelt = { cursor : Xproto.cursor; delay : int32; };;
let create_anim_cursor ~(cid : Xproto.cursor) ~(cursors : animcursorelt list) () : unit Lwt.t = failwith "not implemented";;
type spanfix = { l : fixed; r : fixed; y : fixed; };;
type trap = { top : spanfix; bot : spanfix; };;
let add_traps ~(picture : picture) ~(x_off : int) ~(y_off : int) ~(traps : trap list) () : unit Lwt.t = failwith "not implemented";;
let create_solid_fill ~(picture : picture) ~(color : color) () : unit Lwt.t = failwith "not implemented";;
let create_linear_gradient ~(picture : picture) ~(p1 : pointfix) ~(p2 : pointfix) ~(stops : fixed list) ~(colors : color list) () : unit Lwt.t = failwith "not implemented";;
let create_radial_gradient ~(picture : picture) ~(inner : pointfix) ~(outer : pointfix) ~(inner_radius : fixed) ~(outer_radius : fixed) ~(stops : fixed list) ~(colors : color list) () : unit Lwt.t = failwith "not implemented";;
let create_conical_gradient ~(picture : picture) ~(center : pointfix) ~(angle : fixed) ~(stops : fixed list) ~(colors : color list) () : unit Lwt.t = failwith "not implemented";;
end
module[@warning "-27"] Shape = struct
type op = int;;
type kind = int;;
type so_enum = Set | Union | Intersect | Subtract | Invert;;
type sk_enum = Bounding | Clip | Input;;
type notify_event = { shape_kind : sk_enum; affected_window : Xproto.window; extents_x : int; extents_y : int; extents_width : int; extents_height : int; server_time : Xproto.timestamp; shaped : bool; };;
type query_version_reply = { major_version : int; minor_version : int; };;
let query_version () : query_version_reply Lwt.t = failwith "not implemented";;
let rectangles ~(operation : so_enum) ~(destination_kind : sk_enum) ~(ordering : Xproto.clip_ordering_enum) ~(destination_window : Xproto.window) ~(x_offset : int) ~(y_offset : int) ~(rectangles : Xproto.rectangle list) () : unit Lwt.t = failwith "not implemented";;
let mask ~(operation : so_enum) ~(destination_kind : sk_enum) ~(destination_window : Xproto.window) ~(x_offset : int) ~(y_offset : int) ~(source_bitmap : (Xproto.pixmap_enum, Xproto.pixmap) alt) () : unit Lwt.t = failwith "not implemented";;
let combine ~(operation : so_enum) ~(destination_kind : sk_enum) ~(source_kind : sk_enum) ~(destination_window : Xproto.window) ~(x_offset : int) ~(y_offset : int) ~(source_window : Xproto.window) () : unit Lwt.t = failwith "not implemented";;
let offset ~(destination_kind : sk_enum) ~(destination_window : Xproto.window) ~(x_offset : int) ~(y_offset : int) () : unit Lwt.t = failwith "not implemented";;
type query_extents_reply = { bounding_shaped : bool; clip_shaped : bool; bounding_shape_extents_x : int; bounding_shape_extents_y : int; bounding_shape_extents_width : int; bounding_shape_extents_height : int; clip_shape_extents_x : int; clip_shape_extents_y : int; clip_shape_extents_width : int; clip_shape_extents_height : int; };;
let query_extents ~(destination_window : Xproto.window) () : query_extents_reply Lwt.t = failwith "not implemented";;
let select_input ~(destination_window : Xproto.window) ~(enable : bool) () : unit Lwt.t = failwith "not implemented";;
type input_selected_reply = { enabled : bool; };;
let input_selected ~(destination_window : Xproto.window) () : input_selected_reply Lwt.t = failwith "not implemented";;
type get_rectangles_reply = { ordering : Xproto.clip_ordering_enum; rectangles : Xproto.rectangle list; };;
let get_rectangles ~(window : Xproto.window) ~(source_kind : sk_enum) () : get_rectangles_reply Lwt.t = failwith "not implemented";;
end
module[@warning "-27"] Xfixes = struct
type query_version_reply = { major_version : int32; minor_version : int32; };;
let query_version ~(client_major_version : int32) ~(client_minor_version : int32) () : query_version_reply Lwt.t = failwith "not implemented";;
type save_set_mode_enum = Insert | Delete;;
type save_set_target_enum = Nearest | Root;;
type save_set_mapping_enum = Map | Unmap;;
let change_save_set ~(mode : save_set_mode_enum) ~(target : save_set_target_enum) ~(map : save_set_mapping_enum) ~(window : Xproto.window) () : unit Lwt.t = failwith "not implemented";;
type selection_event_enum = Set_selection_owner | Selection_window_destroy | Selection_client_close;;
type selection_event_mask_mask = [ `Set_selection_owner | `Selection_window_destroy | `Selection_client_close ] list;;
type selection_notify_event = { subtype : selection_event_enum; window : Xproto.window; owner : Xproto.window; selection : Xproto.atom; timestamp : Xproto.timestamp; selection_timestamp : Xproto.timestamp; };;
let select_selection_input ~(window : Xproto.window) ~(selection : Xproto.atom) ~(event_mask : selection_event_mask_mask) () : unit Lwt.t = failwith "not implemented";;
type cursor_notify_enum = Display_cursor;;
type cursor_notify_mask_mask = [ `Display_cursor ] list;;
type cursor_notify_event = { subtype : cursor_notify_enum; window : Xproto.window; cursor_serial : int32; timestamp : Xproto.timestamp; name : (Xproto.atom_enum, Xproto.atom) alt; };;
let select_cursor_input ~(window : Xproto.window) ~(event_mask : cursor_notify_mask_mask) () : unit Lwt.t = failwith "not implemented";;
type get_cursor_image_reply = { x : int; y : int; width : int; height : int; xhot : int; yhot : int; cursor_serial : int32; cursor_image : int32 list; };;
let get_cursor_image () : get_cursor_image_reply Lwt.t = failwith "not implemented";;
type region = xid;;
type bad_region_error = unit;;
type region_enum = None;;
let create_region ~(region : region) ~(rectangles : Xproto.rectangle list) () : unit Lwt.t = failwith "not implemented";;
let create_region_from_bitmap ~(region : region) ~(bitmap : Xproto.pixmap) () : unit Lwt.t = failwith "not implemented";;
let create_region_from_window ~(region : region) ~(window : Xproto.window) ~(kind : Shape.sk_enum) () : unit Lwt.t = failwith "not implemented";;
let create_region_from_gc ~(region : region) ~(gc : Xproto.gcontext) () : unit Lwt.t = failwith "not implemented";;
let create_region_from_picture ~(region : region) ~(picture : Render.picture) () : unit Lwt.t = failwith "not implemented";;
let destroy_region ~(region : region) () : unit Lwt.t = failwith "not implemented";;
let set_region ~(region : region) ~(rectangles : Xproto.rectangle list) () : unit Lwt.t = failwith "not implemented";;
let copy_region ~(source : region) ~(destination : region) () : unit Lwt.t = failwith "not implemented";;
let union_region ~(source1 : region) ~(source2 : region) ~(destination : region) () : unit Lwt.t = failwith "not implemented";;
let intersect_region ~(source1 : region) ~(source2 : region) ~(destination : region) () : unit Lwt.t = failwith "not implemented";;
let subtract_region ~(source1 : region) ~(source2 : region) ~(destination : region) () : unit Lwt.t = failwith "not implemented";;
let invert_region ~(source : region) ~(bounds : Xproto.rectangle) ~(destination : region) () : unit Lwt.t = failwith "not implemented";;
let translate_region ~(region : region) ~(dx : int) ~(dy : int) () : unit Lwt.t = failwith "not implemented";;
let region_extents ~(source : region) ~(destination : region) () : unit Lwt.t = failwith "not implemented";;
type fetch_region_reply = { extents : Xproto.rectangle; rectangles : Xproto.rectangle list; };;
let fetch_region ~(region : region) () : fetch_region_reply Lwt.t = failwith "not implemented";;
let set_gc_clip_region ~(gc : Xproto.gcontext) ~(region : (region_enum, region) alt) ~(x_origin : int) ~(y_origin : int) () : unit Lwt.t = failwith "not implemented";;
let set_window_shape_region ~(dest : Xproto.window) ~(dest_kind : Shape.sk_enum) ~(x_offset : int) ~(y_offset : int) ~(region : (region_enum, region) alt) () : unit Lwt.t = failwith "not implemented";;
let set_picture_clip_region ~(picture : Render.picture) ~(region : (region_enum, region) alt) ~(x_origin : int) ~(y_origin : int) () : unit Lwt.t = failwith "not implemented";;
let set_cursor_name ~(cursor : Xproto.cursor) ~(name : char list) () : unit Lwt.t = failwith "not implemented";;
type get_cursor_name_reply = { atom : (Xproto.atom_enum, Xproto.atom) alt; name : char list; };;
let get_cursor_name ~(cursor : Xproto.cursor) () : get_cursor_name_reply Lwt.t = failwith "not implemented";;
type get_cursor_image_and_name_reply = { x : int; y : int; width : int; height : int; xhot : int; yhot : int; cursor_serial : int32; cursor_atom : (Xproto.atom_enum, Xproto.atom) alt; cursor_image : int32 list; name : char list; };;
let get_cursor_image_and_name () : get_cursor_image_and_name_reply Lwt.t = failwith "not implemented";;
let change_cursor ~(source : Xproto.cursor) ~(destination : Xproto.cursor) () : unit Lwt.t = failwith "not implemented";;
let change_cursor_by_name ~(src : Xproto.cursor) ~(name : char list) () : unit Lwt.t = failwith "not implemented";;
let expand_region ~(source : region) ~(destination : region) ~(left : int) ~(right : int) ~(top : int) ~(bottom : int) () : unit Lwt.t = failwith "not implemented";;
let hide_cursor ~(window : Xproto.window) () : unit Lwt.t = failwith "not implemented";;
let show_cursor ~(window : Xproto.window) () : unit Lwt.t = failwith "not implemented";;
type barrier = xid;;
type barrier_directions_mask = [ `Positive_x | `Positive_y | `Negative_x | `Negative_y ] list;;
let create_pointer_barrier ~(barrier : barrier) ~(window : Xproto.window) ~(x1 : int) ~(y1 : int) ~(x2 : int) ~(y2 : int) ~(directions : barrier_directions_mask) ~(devices : int list) () : unit Lwt.t = failwith "not implemented";;
let delete_pointer_barrier ~(barrier : barrier) () : unit Lwt.t = failwith "not implemented";;
end
module[@warning "-27"] Composite = struct
type redirect_enum = Automatic | Manual;;
type query_version_reply = { major_version : int32; minor_version : int32; };;
let query_version ~(client_major_version : int32) ~(client_minor_version : int32) () : query_version_reply Lwt.t = failwith "not implemented";;
let redirect_window ~(window : Xproto.window) ~(update : redirect_enum) () : unit Lwt.t = failwith "not implemented";;
let redirect_subwindows ~(window : Xproto.window) ~(update : redirect_enum) () : unit Lwt.t = failwith "not implemented";;
let unredirect_window ~(window : Xproto.window) ~(update : redirect_enum) () : unit Lwt.t = failwith "not implemented";;
let unredirect_subwindows ~(window : Xproto.window) ~(update : redirect_enum) () : unit Lwt.t = failwith "not implemented";;
let create_region_from_border_clip ~(region : Xfixes.region) ~(window : Xproto.window) () : unit Lwt.t = failwith "not implemented";;
let name_window_pixmap ~(window : Xproto.window) ~(pixmap : Xproto.pixmap) () : unit Lwt.t = failwith "not implemented";;
type get_overlay_window_reply = { overlay_win : Xproto.window; };;
let get_overlay_window ~(window : Xproto.window) () : get_overlay_window_reply Lwt.t = failwith "not implemented";;
let release_overlay_window ~(window : Xproto.window) () : unit Lwt.t = failwith "not implemented";;
end
module[@warning "-27"] Damage = struct
type damage = xid;;
type report_level_enum = Raw_rectangles | Delta_rectangles | Bounding_box | Non_empty;;
type bad_damage_error = unit;;
type query_version_reply = { major_version : int32; minor_version : int32; };;
let query_version ~(client_major_version : int32) ~(client_minor_version : int32) () : query_version_reply Lwt.t = failwith "not implemented";;
let create ~(damage : damage) ~(drawable : Xproto.drawable) ~(level : report_level_enum) () : unit Lwt.t = failwith "not implemented";;
let destroy ~(damage : damage) () : unit Lwt.t = failwith "not implemented";;
let subtract ~(damage : damage) ~(repair : (Xfixes.region_enum, Xfixes.region) alt) ~(parts : (Xfixes.region_enum, Xfixes.region) alt) () : unit Lwt.t = failwith "not implemented";;
let add ~(drawable : Xproto.drawable) ~(region : Xfixes.region) () : unit Lwt.t = failwith "not implemented";;
type notify_event = { level : report_level_enum; drawable : Xproto.drawable; damage : damage; timestamp : Xproto.timestamp; area : Xproto.rectangle; geometry : Xproto.rectangle; };;
end
module[@warning "-27"] Dpms = struct
type get_version_reply = { server_major_version : int; server_minor_version : int; };;
let get_version ~(client_major_version : int) ~(client_minor_version : int) () : get_version_reply Lwt.t = failwith "not implemented";;
type capable_reply = { capable : bool; };;
let capable () : capable_reply Lwt.t = failwith "not implemented";;
type get_timeouts_reply = { standby_timeout : int; suspend_timeout : int; off_timeout : int; };;
let get_timeouts () : get_timeouts_reply Lwt.t = failwith "not implemented";;
let set_timeouts ~(standby_timeout : int) ~(suspend_timeout : int) ~(off_timeout : int) () : unit Lwt.t = failwith "not implemented";;
let enable () : unit Lwt.t = failwith "not implemented";;
let disable () : unit Lwt.t = failwith "not implemented";;
type dpms_mode_enum = On | Standby | Suspend | Off;;
let force_level ~(power_level : dpms_mode_enum) () : unit Lwt.t = failwith "not implemented";;
type info_reply = { power_level : dpms_mode_enum; state : bool; };;
let info () : info_reply Lwt.t = failwith "not implemented";;
end
module[@warning "-27"] Dri2 = struct
type attachment_enum = Buffer_front_left | Buffer_back_left | Buffer_front_right | Buffer_back_right | Buffer_depth | Buffer_stencil | Buffer_accum | Buffer_fake_front_left | Buffer_fake_front_right | Buffer_depth_stencil | Buffer_hiz;;
type driver_type_enum = Dri | Vdpau;;
type event_type_enum = Exchange_complete | Blit_complete | Flip_complete;;
type dri2_buffer = { attachment : attachment_enum; name : int32; pitch : int32; cpp : int32; flags : int32; };;
type attach_format = { attachment : attachment_enum; format : int32; };;
type query_version_reply = { major_version : int32; minor_version : int32; };;
let query_version ~(major_version : int32) ~(minor_version : int32) () : query_version_reply Lwt.t = failwith "not implemented";;
type connect_reply = { driver_name : char list; alignment_pad : char list; device_name : char list; };;
let connect ~(window : Xproto.window) ~(driver_type : driver_type_enum) () : connect_reply Lwt.t = failwith "not implemented";;
type authenticate_reply = { authenticated : int32; };;
let authenticate ~(window : Xproto.window) ~(magic : int32) () : authenticate_reply Lwt.t = failwith "not implemented";;
let create_drawable ~(drawable : Xproto.drawable) () : unit Lwt.t = failwith "not implemented";;
let destroy_drawable ~(drawable : Xproto.drawable) () : unit Lwt.t = failwith "not implemented";;
type get_buffers_reply = { width : int32; height : int32; buffers : dri2_buffer list; };;
let get_buffers ~(drawable : Xproto.drawable) ~(attachments : int32 list) () : get_buffers_reply Lwt.t = failwith "not implemented";;
type copy_region_reply = unit;;
let copy_region ~(drawable : Xproto.drawable) ~(region : int32) ~(dest : int32) ~(src : int32) () : copy_region_reply Lwt.t = failwith "not implemented";;
type get_buffers_with_format_reply = { width : int32; height : int32; buffers : dri2_buffer list; };;
let get_buffers_with_format ~(drawable : Xproto.drawable) ~(attachments : attach_format list) () : get_buffers_with_format_reply Lwt.t = failwith "not implemented";;
type swap_buffers_reply = { swap_hi : int32; swap_lo : int32; };;
let swap_buffers ~(drawable : Xproto.drawable) ~(target_msc_hi : int32) ~(target_msc_lo : int32) ~(divisor_hi : int32) ~(divisor_lo : int32) ~(remainder_hi : int32) ~(remainder_lo : int32) () : swap_buffers_reply Lwt.t = failwith "not implemented";;
type get_msc_reply = { ust_hi : int32; ust_lo : int32; msc_hi : int32; msc_lo : int32; sbc_hi : int32; sbc_lo : int32; };;
let get_msc ~(drawable : Xproto.drawable) () : get_msc_reply Lwt.t = failwith "not implemented";;
type wait_msc_reply = { ust_hi : int32; ust_lo : int32; msc_hi : int32; msc_lo : int32; sbc_hi : int32; sbc_lo : int32; };;
let wait_msc ~(drawable : Xproto.drawable) ~(target_msc_hi : int32) ~(target_msc_lo : int32) ~(divisor_hi : int32) ~(divisor_lo : int32) ~(remainder_hi : int32) ~(remainder_lo : int32) () : wait_msc_reply Lwt.t = failwith "not implemented";;
type wait_sbc_reply = { ust_hi : int32; ust_lo : int32; msc_hi : int32; msc_lo : int32; sbc_hi : int32; sbc_lo : int32; };;
let wait_sbc ~(drawable : Xproto.drawable) ~(target_sbc_hi : int32) ~(target_sbc_lo : int32) () : wait_sbc_reply Lwt.t = failwith "not implemented";;
let swap_interval ~(drawable : Xproto.drawable) ~(interval : int32) () : unit Lwt.t = failwith "not implemented";;
type get_param_reply = { is_param_recognized : bool; value_hi : int32; value_lo : int32; };;
let get_param ~(drawable : Xproto.drawable) ~(param : int32) () : get_param_reply Lwt.t = failwith "not implemented";;
type buffer_swap_complete_event = { event_type : event_type_enum; drawable : Xproto.drawable; ust_hi : int32; ust_lo : int32; msc_hi : int32; msc_lo : int32; sbc : int32; };;
type invalidate_buffers_event = { drawable : Xproto.drawable; };;
end
module[@warning "-27"] Dri3 = struct
type query_version_reply = { major_version : int32; minor_version : int32; };;
let query_version ~(major_version : int32) ~(minor_version : int32) () : query_version_reply Lwt.t = failwith "not implemented";;
type open_reply = { nfd : int; device_fd : file_descr; };;
let open_ ~(drawable : Xproto.drawable) ~(provider : int32) () : open_reply Lwt.t = failwith "not implemented";;
let pixmap_from_buffer ~(pixmap : Xproto.pixmap) ~(drawable : Xproto.drawable) ~(size : int32) ~(width : int) ~(height : int) ~(stride : int) ~(depth : int) ~(bpp : int) ~(pixmap_fd : file_descr) () : unit Lwt.t = failwith "not implemented";;
type buffer_from_pixmap_reply = { nfd : int; size : int32; width : int; height : int; stride : int; depth : int; bpp : int; pixmap_fd : file_descr; };;
let buffer_from_pixmap ~(pixmap : Xproto.pixmap) () : buffer_from_pixmap_reply Lwt.t = failwith "not implemented";;
let fence_from_fd ~(drawable : Xproto.drawable) ~(fence : int32) ~(initially_triggered : bool) ~(fence_fd : file_descr) () : unit Lwt.t = failwith "not implemented";;
type fd_from_fence_reply = { nfd : int; fence_fd : file_descr; };;
let fd_from_fence ~(drawable : Xproto.drawable) ~(fence : int32) () : fd_from_fence_reply Lwt.t = failwith "not implemented";;
type get_supported_modifiers_reply = { window_modifiers : int64 list; screen_modifiers : int64 list; };;
let get_supported_modifiers ~(window : int32) ~(depth : int) ~(bpp : int) () : get_supported_modifiers_reply Lwt.t = failwith "not implemented";;
let pixmap_from_buffers ~(pixmap : Xproto.pixmap) ~(window : Xproto.window) ~(width : int) ~(height : int) ~(stride0 : int32) ~(offset0 : int32) ~(stride1 : int32) ~(offset1 : int32) ~(stride2 : int32) ~(offset2 : int32) ~(stride3 : int32) ~(offset3 : int32) ~(depth : int) ~(bpp : int) ~(modifier : int64) ~(buffers : file_descr list) () : unit Lwt.t = failwith "not implemented";;
type buffers_from_pixmap_reply = { width : int; height : int; modifier : int64; depth : int; bpp : int; strides : int32 list; offsets : int32 list; buffers : file_descr list; };;
let buffers_from_pixmap ~(pixmap : Xproto.pixmap) () : buffers_from_pixmap_reply Lwt.t = failwith "not implemented";;
end
module[@warning "-27"] Ge = struct
type query_version_reply = { major_version : int; minor_version : int; };;
let query_version ~(client_major_version : int) ~(client_minor_version : int) () : query_version_reply Lwt.t = failwith "not implemented";;
end
module[@warning "-27"] Glx = struct
type pixmap = xid;;
type context = xid;;
type pbuffer = xid;;
type window = xid;;
type fbconfig = xid;;
type drawable = xid;;
type float32 = float;;
type float64 = float;;
type bool32 = int32;;
type context_tag = int32;;
type generic_error = { bad_value : int32; minor_opcode : int; major_opcode : int; };;
type bad_context_error = generic_error;;
type bad_context_state_error = generic_error;;
type bad_drawable_error = generic_error;;
type bad_pixmap_error = generic_error;;
type bad_context_tag_error = generic_error;;
type bad_current_window_error = generic_error;;
type bad_render_request_error = generic_error;;
type bad_large_request_error = generic_error;;
type unsupported_private_request_error = generic_error;;
type bad_fb_config_error = generic_error;;
type bad_pbuffer_error = generic_error;;
type bad_current_drawable_error = generic_error;;
type bad_window_error = generic_error;;
type glx_bad_profile_arb_error = generic_error;;
type pbuffer_clobber_event = { event_type : int; draw_type : int; drawable : drawable; b_mask : int32; aux_buffer : int; x : int; y : int; width : int; height : int; count : int; };;
type buffer_swap_complete_event = { event_type : int; drawable : drawable; ust_hi : int32; ust_lo : int32; msc_hi : int32; msc_lo : int32; sbc : int32; };;
type pbcet_enum = Damaged | Saved;;
type pbcdt_enum = Window | Pbuffer;;
let render ~(context_tag : context_tag) ~(data : char list) () : unit Lwt.t = failwith "not implemented";;
let render_large ~(context_tag : context_tag) ~(request_num : int) ~(request_total : int) ~(data : char list) () : unit Lwt.t = failwith "not implemented";;
let create_context ~(context : context) ~(visual : Xproto.visualid) ~(screen : int32) ~(share_list : context) ~(is_direct : bool) () : unit Lwt.t = failwith "not implemented";;
let destroy_context ~(context : context) () : unit Lwt.t = failwith "not implemented";;
type make_current_reply = { context_tag : context_tag; };;
let make_current ~(drawable : drawable) ~(context : context) ~(old_context_tag : context_tag) () : make_current_reply Lwt.t = failwith "not implemented";;
type is_direct_reply = { is_direct : bool; };;
let is_direct ~(context : context) () : is_direct_reply Lwt.t = failwith "not implemented";;
type query_version_reply = { major_version : int32; minor_version : int32; };;
let query_version ~(major_version : int32) ~(minor_version : int32) () : query_version_reply Lwt.t = failwith "not implemented";;
let wait_gl ~(context_tag : context_tag) () : unit Lwt.t = failwith "not implemented";;
let wait_x ~(context_tag : context_tag) () : unit Lwt.t = failwith "not implemented";;
let copy_context ~(src : context) ~(dest : context) ~(mask : int32) ~(src_context_tag : context_tag) () : unit Lwt.t = failwith "not implemented";;
type gc_mask = ([ `Gl_current_bit | `Gl_point_bit | `Gl_line_bit | `Gl_polygon_bit | `Gl_polygon_stipple_bit | `Gl_pixel_mode_bit | `Gl_lighting_bit | `Gl_fog_bit | `Gl_depth_buffer_bit | `Gl_accum_buffer_bit | `Gl_stencil_buffer_bit | `Gl_viewport_bit | `Gl_transform_bit | `Gl_enable_bit | `Gl_color_buffer_bit | `Gl_hint_bit | `Gl_eval_bit | `Gl_list_bit | `Gl_texture_bit | `Gl_scissor_bit ], [ `Gl_all_attrib_bits ]) mask;;
let swap_buffers ~(context_tag : context_tag) ~(drawable : drawable) () : unit Lwt.t = failwith "not implemented";;
let use_x_font ~(context_tag : context_tag) ~(font : Xproto.font) ~(first : int32) ~(count : int32) ~(list_base : int32) () : unit Lwt.t = failwith "not implemented";;
let create_glx_pixmap ~(screen : int32) ~(visual : Xproto.visualid) ~(pixmap : Xproto.pixmap) ~(glx_pixmap : pixmap) () : unit Lwt.t = failwith "not implemented";;
type get_visual_configs_reply = { num_visuals : int32; num_properties : int32; property_list : int32 list; };;
let get_visual_configs ~(screen : int32) () : get_visual_configs_reply Lwt.t = failwith "not implemented";;
let destroy_glx_pixmap ~(glx_pixmap : pixmap) () : unit Lwt.t = failwith "not implemented";;
let vendor_private ~(vendor_code : int32) ~(context_tag : context_tag) ~(data : char list) () : unit Lwt.t = failwith "not implemented";;
type vendor_private_with_reply_reply = { retval : int32; data1 : char list; data2 : char list; };;
let vendor_private_with_reply ~(vendor_code : int32) ~(context_tag : context_tag) ~(data : char list) () : vendor_private_with_reply_reply Lwt.t = failwith "not implemented";;
type query_extensions_string_reply = { n : int32; };;
let query_extensions_string ~(screen : int32) () : query_extensions_string_reply Lwt.t = failwith "not implemented";;
type query_server_string_reply = { string : char list; };;
let query_server_string ~(screen : int32) ~(name : int32) () : query_server_string_reply Lwt.t = failwith "not implemented";;
let client_info ~(major_version : int32) ~(minor_version : int32) ~(string : char list) () : unit Lwt.t = failwith "not implemented";;
type get_fb_configs_reply = { num_f_b_configs : int32; num_properties : int32; property_list : int32 list; };;
let get_fb_configs ~(screen : int32) () : get_fb_configs_reply Lwt.t = failwith "not implemented";;
let create_pixmap ~(screen : int32) ~(fbconfig : fbconfig) ~(pixmap : Xproto.pixmap) ~(glx_pixmap : pixmap) ~(num_attribs : int32) ~(attribs : int32 list) () : unit Lwt.t = failwith "not implemented";;
let destroy_pixmap ~(glx_pixmap : pixmap) () : unit Lwt.t = failwith "not implemented";;
let create_new_context ~(context : context) ~(fbconfig : fbconfig) ~(screen : int32) ~(render_type : int32) ~(share_list : context) ~(is_direct : bool) () : unit Lwt.t = failwith "not implemented";;
type query_context_reply = { num_attribs : int32; attribs : int32 list; };;
let query_context ~(context : context) () : query_context_reply Lwt.t = failwith "not implemented";;
type make_context_current_reply = { context_tag : context_tag; };;
let make_context_current ~(old_context_tag : context_tag) ~(drawable : drawable) ~(read_drawable : drawable) ~(context : context) () : make_context_current_reply Lwt.t = failwith "not implemented";;
let create_pbuffer ~(screen : int32) ~(fbconfig : fbconfig) ~(pbuffer : pbuffer) ~(num_attribs : int32) ~(attribs : int32 list) () : unit Lwt.t = failwith "not implemented";;
let destroy_pbuffer ~(pbuffer : pbuffer) () : unit Lwt.t = failwith "not implemented";;
type get_drawable_attributes_reply = { num_attribs : int32; attribs : int32 list; };;
let get_drawable_attributes ~(drawable : drawable) () : get_drawable_attributes_reply Lwt.t = failwith "not implemented";;
let change_drawable_attributes ~(drawable : drawable) ~(num_attribs : int32) ~(attribs : int32 list) () : unit Lwt.t = failwith "not implemented";;
let create_window ~(screen : int32) ~(fbconfig : fbconfig) ~(window : Xproto.window) ~(glx_window : window) ~(num_attribs : int32) ~(attribs : int32 list) () : unit Lwt.t = failwith "not implemented";;
let delete_window ~(glxwindow : window) () : unit Lwt.t = failwith "not implemented";;
let set_client_info_arb ~(major_version : int32) ~(minor_version : int32) ~(num_versions : int32) ~(gl_versions : int32 list) ~(gl_extension_string : char list) ~(glx_extension_string : char list) () : unit Lwt.t = failwith "not implemented";;
let create_context_attribs_arb ~(context : context) ~(fbconfig : fbconfig) ~(screen : int32) ~(share_list : context) ~(is_direct : bool) ~(num_attribs : int32) ~(attribs : int32 list) () : unit Lwt.t = failwith "not implemented";;
let set_client_info2_arb ~(major_version : int32) ~(minor_version : int32) ~(num_versions : int32) ~(gl_versions : int32 list) ~(gl_extension_string : char list) ~(glx_extension_string : char list) () : unit Lwt.t = failwith "not implemented";;
let new_list ~(context_tag : context_tag) ~(list : int32) ~(mode : int32) () : unit Lwt.t = failwith "not implemented";;
let end_list ~(context_tag : context_tag) () : unit Lwt.t = failwith "not implemented";;
let delete_lists ~(context_tag : context_tag) ~(list : int32) ~(range : int32) () : unit Lwt.t = failwith "not implemented";;
type gen_lists_reply = { ret_val : int32; };;
let gen_lists ~(context_tag : context_tag) ~(range : int32) () : gen_lists_reply Lwt.t = failwith "not implemented";;
let feedback_buffer ~(context_tag : context_tag) ~(size : int32) ~(type_ : int32) () : unit Lwt.t = failwith "not implemented";;
let select_buffer ~(context_tag : context_tag) ~(size : int32) () : unit Lwt.t = failwith "not implemented";;
type render_mode_reply = { ret_val : int32; new_mode : int32; data : int32 list; };;
let render_mode ~(context_tag : context_tag) ~(mode : int32) () : render_mode_reply Lwt.t = failwith "not implemented";;
type rm_enum = Gl_render | Gl_feedback | Gl_select;;
type finish_reply = unit;;
let finish ~(context_tag : context_tag) () : finish_reply Lwt.t = failwith "not implemented";;
let pixel_storef ~(context_tag : context_tag) ~(pname : int32) ~(datum : float32) () : unit Lwt.t = failwith "not implemented";;
let pixel_storei ~(context_tag : context_tag) ~(pname : int32) ~(datum : int32) () : unit Lwt.t = failwith "not implemented";;
type read_pixels_reply = { data : char list; };;
let read_pixels ~(context_tag : context_tag) ~(x : int32) ~(y : int32) ~(width : int32) ~(height : int32) ~(format : int32) ~(type_ : int32) ~(swap_bytes : bool) ~(lsb_first : bool) () : read_pixels_reply Lwt.t = failwith "not implemented";;
type get_booleanv_reply = { datum : bool; data : bool list; };;
let get_booleanv ~(context_tag : context_tag) ~(pname : int32) () : get_booleanv_reply Lwt.t = failwith "not implemented";;
type get_clip_plane_reply = { data : float64 list; };;
let get_clip_plane ~(context_tag : context_tag) ~(plane : int32) () : get_clip_plane_reply Lwt.t = failwith "not implemented";;
type get_doublev_reply = { datum : float64; data : float64 list; };;
let get_doublev ~(context_tag : context_tag) ~(pname : int32) () : get_doublev_reply Lwt.t = failwith "not implemented";;
type get_error_reply = { error : int32; };;
let get_error ~(context_tag : context_tag) () : get_error_reply Lwt.t = failwith "not implemented";;
type get_floatv_reply = { datum : float32; data : float32 list; };;
let get_floatv ~(context_tag : context_tag) ~(pname : int32) () : get_floatv_reply Lwt.t = failwith "not implemented";;
type get_integerv_reply = { datum : int32; data : int32 list; };;
let get_integerv ~(context_tag : context_tag) ~(pname : int32) () : get_integerv_reply Lwt.t = failwith "not implemented";;
type get_lightfv_reply = { datum : float32; data : float32 list; };;
let get_lightfv ~(context_tag : context_tag) ~(light : int32) ~(pname : int32) () : get_lightfv_reply Lwt.t = failwith "not implemented";;
type get_lightiv_reply = { datum : int32; data : int32 list; };;
let get_lightiv ~(context_tag : context_tag) ~(light : int32) ~(pname : int32) () : get_lightiv_reply Lwt.t = failwith "not implemented";;
type get_mapdv_reply = { datum : float64; data : float64 list; };;
let get_mapdv ~(context_tag : context_tag) ~(target : int32) ~(query : int32) () : get_mapdv_reply Lwt.t = failwith "not implemented";;
type get_mapfv_reply = { datum : float32; data : float32 list; };;
let get_mapfv ~(context_tag : context_tag) ~(target : int32) ~(query : int32) () : get_mapfv_reply Lwt.t = failwith "not implemented";;
type get_mapiv_reply = { datum : int32; data : int32 list; };;
let get_mapiv ~(context_tag : context_tag) ~(target : int32) ~(query : int32) () : get_mapiv_reply Lwt.t = failwith "not implemented";;
type get_materialfv_reply = { datum : float32; data : float32 list; };;
let get_materialfv ~(context_tag : context_tag) ~(face : int32) ~(pname : int32) () : get_materialfv_reply Lwt.t = failwith "not implemented";;
type get_materialiv_reply = { datum : int32; data : int32 list; };;
let get_materialiv ~(context_tag : context_tag) ~(face : int32) ~(pname : int32) () : get_materialiv_reply Lwt.t = failwith "not implemented";;
type get_pixel_mapfv_reply = { datum : float32; data : float32 list; };;
let get_pixel_mapfv ~(context_tag : context_tag) ~(map : int32) () : get_pixel_mapfv_reply Lwt.t = failwith "not implemented";;
type get_pixel_mapuiv_reply = { datum : int32; data : int32 list; };;
let get_pixel_mapuiv ~(context_tag : context_tag) ~(map : int32) () : get_pixel_mapuiv_reply Lwt.t = failwith "not implemented";;
type get_pixel_mapusv_reply = { datum : int; data : int list; };;
let get_pixel_mapusv ~(context_tag : context_tag) ~(map : int32) () : get_pixel_mapusv_reply Lwt.t = failwith "not implemented";;
type get_polygon_stipple_reply = { data : char list; };;
let get_polygon_stipple ~(context_tag : context_tag) ~(lsb_first : bool) () : get_polygon_stipple_reply Lwt.t = failwith "not implemented";;
type get_string_reply = { string : char list; };;
let get_string ~(context_tag : context_tag) ~(name : int32) () : get_string_reply Lwt.t = failwith "not implemented";;
type get_tex_envfv_reply = { datum : float32; data : float32 list; };;
let get_tex_envfv ~(context_tag : context_tag) ~(target : int32) ~(pname : int32) () : get_tex_envfv_reply Lwt.t = failwith "not implemented";;
type get_tex_enviv_reply = { datum : int32; data : int32 list; };;
let get_tex_enviv ~(context_tag : context_tag) ~(target : int32) ~(pname : int32) () : get_tex_enviv_reply Lwt.t = failwith "not implemented";;
type get_tex_gendv_reply = { datum : float64; data : float64 list; };;
let get_tex_gendv ~(context_tag : context_tag) ~(coord : int32) ~(pname : int32) () : get_tex_gendv_reply Lwt.t = failwith "not implemented";;
type get_tex_genfv_reply = { datum : float32; data : float32 list; };;
let get_tex_genfv ~(context_tag : context_tag) ~(coord : int32) ~(pname : int32) () : get_tex_genfv_reply Lwt.t = failwith "not implemented";;
type get_tex_geniv_reply = { datum : int32; data : int32 list; };;
let get_tex_geniv ~(context_tag : context_tag) ~(coord : int32) ~(pname : int32) () : get_tex_geniv_reply Lwt.t = failwith "not implemented";;
type get_tex_image_reply = { width : int32; height : int32; depth : int32; data : char list; };;
let get_tex_image ~(context_tag : context_tag) ~(target : int32) ~(level : int32) ~(format : int32) ~(type_ : int32) ~(swap_bytes : bool) () : get_tex_image_reply Lwt.t = failwith "not implemented";;
type get_tex_parameterfv_reply = { datum : float32; data : float32 list; };;
let get_tex_parameterfv ~(context_tag : context_tag) ~(target : int32) ~(pname : int32) () : get_tex_parameterfv_reply Lwt.t = failwith "not implemented";;
type get_tex_parameteriv_reply = { datum : int32; data : int32 list; };;
let get_tex_parameteriv ~(context_tag : context_tag) ~(target : int32) ~(pname : int32) () : get_tex_parameteriv_reply Lwt.t = failwith "not implemented";;
type get_tex_level_parameterfv_reply = { datum : float32; data : float32 list; };;
let get_tex_level_parameterfv ~(context_tag : context_tag) ~(target : int32) ~(level : int32) ~(pname : int32) () : get_tex_level_parameterfv_reply Lwt.t = failwith "not implemented";;
type get_tex_level_parameteriv_reply = { datum : int32; data : int32 list; };;
let get_tex_level_parameteriv ~(context_tag : context_tag) ~(target : int32) ~(level : int32) ~(pname : int32) () : get_tex_level_parameteriv_reply Lwt.t = failwith "not implemented";;
type is_enabled_reply = { ret_val : bool32; };;
let is_enabled ~(context_tag : context_tag) ~(capability : int32) () : is_enabled_reply Lwt.t = failwith "not implemented";;
type is_list_reply = { ret_val : bool32; };;
let is_list ~(context_tag : context_tag) ~(list : int32) () : is_list_reply Lwt.t = failwith "not implemented";;
let flush ~(context_tag : context_tag) () : unit Lwt.t = failwith "not implemented";;
type are_textures_resident_reply = { ret_val : bool32; data : bool list; };;
let are_textures_resident ~(context_tag : context_tag) ~(textures : int32 list) () : are_textures_resident_reply Lwt.t = failwith "not implemented";;
let delete_textures ~(context_tag : context_tag) ~(textures : int32 list) () : unit Lwt.t = failwith "not implemented";;
type gen_textures_reply = { data : int32 list; };;
let gen_textures ~(context_tag : context_tag) ~(n : int32) () : gen_textures_reply Lwt.t = failwith "not implemented";;
type is_texture_reply = { ret_val : bool32; };;
let is_texture ~(context_tag : context_tag) ~(texture : int32) () : is_texture_reply Lwt.t = failwith "not implemented";;
type get_color_table_reply = { width : int32; data : char list; };;
let get_color_table ~(context_tag : context_tag) ~(target : int32) ~(format : int32) ~(type_ : int32) ~(swap_bytes : bool) () : get_color_table_reply Lwt.t = failwith "not implemented";;
type get_color_table_parameterfv_reply = { datum : float32; data : float32 list; };;
let get_color_table_parameterfv ~(context_tag : context_tag) ~(target : int32) ~(pname : int32) () : get_color_table_parameterfv_reply Lwt.t = failwith "not implemented";;
type get_color_table_parameteriv_reply = { datum : int32; data : int32 list; };;
let get_color_table_parameteriv ~(context_tag : context_tag) ~(target : int32) ~(pname : int32) () : get_color_table_parameteriv_reply Lwt.t = failwith "not implemented";;
type get_convolution_filter_reply = { width : int32; height : int32; data : char list; };;
let get_convolution_filter ~(context_tag : context_tag) ~(target : int32) ~(format : int32) ~(type_ : int32) ~(swap_bytes : bool) () : get_convolution_filter_reply Lwt.t = failwith "not implemented";;
type get_convolution_parameterfv_reply = { datum : float32; data : float32 list; };;
let get_convolution_parameterfv ~(context_tag : context_tag) ~(target : int32) ~(pname : int32) () : get_convolution_parameterfv_reply Lwt.t = failwith "not implemented";;
type get_convolution_parameteriv_reply = { datum : int32; data : int32 list; };;
let get_convolution_parameteriv ~(context_tag : context_tag) ~(target : int32) ~(pname : int32) () : get_convolution_parameteriv_reply Lwt.t = failwith "not implemented";;
type get_separable_filter_reply = { row_w : int32; col_h : int32; rows_and_cols : char list; };;
let get_separable_filter ~(context_tag : context_tag) ~(target : int32) ~(format : int32) ~(type_ : int32) ~(swap_bytes : bool) () : get_separable_filter_reply Lwt.t = failwith "not implemented";;
type get_histogram_reply = { width : int32; data : char list; };;
let get_histogram ~(context_tag : context_tag) ~(target : int32) ~(format : int32) ~(type_ : int32) ~(swap_bytes : bool) ~(reset : bool) () : get_histogram_reply Lwt.t = failwith "not implemented";;
type get_histogram_parameterfv_reply = { datum : float32; data : float32 list; };;
let get_histogram_parameterfv ~(context_tag : context_tag) ~(target : int32) ~(pname : int32) () : get_histogram_parameterfv_reply Lwt.t = failwith "not implemented";;
type get_histogram_parameteriv_reply = { datum : int32; data : int32 list; };;
let get_histogram_parameteriv ~(context_tag : context_tag) ~(target : int32) ~(pname : int32) () : get_histogram_parameteriv_reply Lwt.t = failwith "not implemented";;
type get_minmax_reply = { data : char list; };;
let get_minmax ~(context_tag : context_tag) ~(target : int32) ~(format : int32) ~(type_ : int32) ~(swap_bytes : bool) ~(reset : bool) () : get_minmax_reply Lwt.t = failwith "not implemented";;
type get_minmax_parameterfv_reply = { datum : float32; data : float32 list; };;
let get_minmax_parameterfv ~(context_tag : context_tag) ~(target : int32) ~(pname : int32) () : get_minmax_parameterfv_reply Lwt.t = failwith "not implemented";;
type get_minmax_parameteriv_reply = { datum : int32; data : int32 list; };;
let get_minmax_parameteriv ~(context_tag : context_tag) ~(target : int32) ~(pname : int32) () : get_minmax_parameteriv_reply Lwt.t = failwith "not implemented";;
type get_compressed_tex_image_arb_reply = { size : int32; data : char list; };;
let get_compressed_tex_image_arb ~(context_tag : context_tag) ~(target : int32) ~(level : int32) () : get_compressed_tex_image_arb_reply Lwt.t = failwith "not implemented";;
let delete_queries_arb ~(context_tag : context_tag) ~(ids : int32 list) () : unit Lwt.t = failwith "not implemented";;
type gen_queries_arb_reply = { data : int32 list; };;
let gen_queries_arb ~(context_tag : context_tag) ~(n : int32) () : gen_queries_arb_reply Lwt.t = failwith "not implemented";;
type is_query_arb_reply = { ret_val : bool32; };;
let is_query_arb ~(context_tag : context_tag) ~(id : int32) () : is_query_arb_reply Lwt.t = failwith "not implemented";;
type get_queryiv_arb_reply = { datum : int32; data : int32 list; };;
let get_queryiv_arb ~(context_tag : context_tag) ~(target : int32) ~(pname : int32) () : get_queryiv_arb_reply Lwt.t = failwith "not implemented";;
type get_query_objectiv_arb_reply = { datum : int32; data : int32 list; };;
let get_query_objectiv_arb ~(context_tag : context_tag) ~(id : int32) ~(pname : int32) () : get_query_objectiv_arb_reply Lwt.t = failwith "not implemented";;
type get_query_objectuiv_arb_reply = { datum : int32; data : int32 list; };;
let get_query_objectuiv_arb ~(context_tag : context_tag) ~(id : int32) ~(pname : int32) () : get_query_objectuiv_arb_reply Lwt.t = failwith "not implemented";;
end
module[@warning "-27"] Randr = struct
type mode = xid;;
type crtc = xid;;
type output = xid;;
type provider = xid;;
type lease = xid;;
type bad_output_error = unit;;
type bad_crtc_error = unit;;
type bad_mode_error = unit;;
type bad_provider_error = unit;;
type rotation_mask = [ `Rotate_0 | `Rotate_90 | `Rotate_180 | `Rotate_270 | `Reflect_x | `Reflect_y ] list;;
type screen_size = { width : int; height : int; mwidth : int; mheight : int; };;
type refresh_rates = { rates : int list; };;
type query_version_reply = { major_version : int32; minor_version : int32; };;
let query_version ~(major_version : int32) ~(minor_version : int32) () : query_version_reply Lwt.t = failwith "not implemented";;
type set_config_enum = Success | Invalid_config_time | Invalid_time | Failed;;
type set_screen_config_reply = { status : set_config_enum; new_timestamp : Xproto.timestamp; config_timestamp : Xproto.timestamp; root : Xproto.window; subpixel_order : Render.sub_pixel_enum; };;
let set_screen_config ~(window : Xproto.window) ~(timestamp : Xproto.timestamp) ~(config_timestamp : Xproto.timestamp) ~(size_id : int) ~(rotation : rotation_mask) ~(rate : int) () : set_screen_config_reply Lwt.t = failwith "not implemented";;
type notify_mask_mask = [ `Screen_change | `Crtc_change | `Output_change | `Output_property | `Provider_change | `Provider_property | `Resource_change | `Lease ] list;;
let select_input ~(window : Xproto.window) ~(enable : notify_mask_mask) () : unit Lwt.t = failwith "not implemented";;
type get_screen_info_reply = { rotations : rotation_mask; root : Xproto.window; timestamp : Xproto.timestamp; config_timestamp : Xproto.timestamp; size_id : int; rotation : rotation_mask; rate : int; n_info : int; sizes : screen_size list; rates : refresh_rates list; };;
let get_screen_info ~(window : Xproto.window) () : get_screen_info_reply Lwt.t = failwith "not implemented";;
type get_screen_size_range_reply = { min_width : int; min_height : int; max_width : int; max_height : int; };;
let get_screen_size_range ~(window : Xproto.window) () : get_screen_size_range_reply Lwt.t = failwith "not implemented";;
let set_screen_size ~(window : Xproto.window) ~(width : int) ~(height : int) ~(mm_width : int32) ~(mm_height : int32) () : unit Lwt.t = failwith "not implemented";;
type mode_flag_mask = [ `Hsync_positive | `Hsync_negative | `Vsync_positive | `Vsync_negative | `Interlace | `Double_scan | `Csync | `Csync_positive | `Csync_negative | `Hskew_present | `Bcast | `Pixel_multiplex | `Double_clock | `Halve_clock ] list;;
type mode_info = { id : int32; width : int; height : int; dot_clock : int32; hsync_start : int; hsync_end : int; htotal : int; hskew : int; vsync_start : int; vsync_end : int; vtotal : int; name_len : int; mode_flags : mode_flag_mask; };;
type get_screen_resources_reply = { timestamp : Xproto.timestamp; config_timestamp : Xproto.timestamp; crtcs : crtc list; outputs : output list; modes : mode_info list; names : char list; };;
let get_screen_resources ~(window : Xproto.window) () : get_screen_resources_reply Lwt.t = failwith "not implemented";;
type connection_enum = Connected | Disconnected | Unknown;;
type get_output_info_reply = { status : set_config_enum; timestamp : Xproto.timestamp; crtc : crtc; mm_width : int32; mm_height : int32; connection : connection_enum; subpixel_order : Render.sub_pixel_enum; num_preferred : int; crtcs : crtc list; modes : mode list; clones : output list; name : char list; };;
let get_output_info ~(output : output) ~(config_timestamp : Xproto.timestamp) () : get_output_info_reply Lwt.t = failwith "not implemented";;
type list_output_properties_reply = { atoms : Xproto.atom list; };;
let list_output_properties ~(output : output) () : list_output_properties_reply Lwt.t = failwith "not implemented";;
type query_output_property_reply = { pending : bool; range : bool; immutable : bool; valid_values : int32 list; };;
let query_output_property ~(output : output) ~(property : Xproto.atom) () : query_output_property_reply Lwt.t = failwith "not implemented";;
let configure_output_property ~(output : output) ~(property : Xproto.atom) ~(pending : bool) ~(range : bool) ~(values : int32 list) () : unit Lwt.t = failwith "not implemented";;
let change_output_property ~(output : output) ~(property : Xproto.atom) ~(type_ : Xproto.atom) ~(format : int) ~(mode : Xproto.prop_mode_enum) ~(num_units : int32) ~(data : char list) () : unit Lwt.t = failwith "not implemented";;
let delete_output_property ~(output : output) ~(property : Xproto.atom) () : unit Lwt.t = failwith "not implemented";;
type get_output_property_reply = { format : int; type_ : (Xproto.atom_enum, Xproto.atom) alt; bytes_after : int32; num_items : int32; data : char list; };;
let get_output_property ~(output : output) ~(property : Xproto.atom) ~(type_ : (Xproto.get_property_type_enum, Xproto.atom) alt) ~(long_offset : int32) ~(long_length : int32) ~(delete : bool) ~(pending : bool) () : get_output_property_reply Lwt.t = failwith "not implemented";;
type create_mode_reply = { mode : mode; };;
let create_mode ~(window : Xproto.window) ~(mode_info : mode_info) ~(name : char list) () : create_mode_reply Lwt.t = failwith "not implemented";;
let destroy_mode ~(mode : mode) () : unit Lwt.t = failwith "not implemented";;
let add_output_mode ~(output : output) ~(mode : mode) () : unit Lwt.t = failwith "not implemented";;
let delete_output_mode ~(output : output) ~(mode : mode) () : unit Lwt.t = failwith "not implemented";;
type get_crtc_info_reply = { status : set_config_enum; timestamp : Xproto.timestamp; x : int; y : int; width : int; height : int; mode : mode; rotation : rotation_mask; rotations : rotation_mask; outputs : output list; possible : output list; };;
let get_crtc_info ~(crtc : crtc) ~(config_timestamp : Xproto.timestamp) () : get_crtc_info_reply Lwt.t = failwith "not implemented";;
type set_crtc_config_reply = { status : set_config_enum; timestamp : Xproto.timestamp; };;
let set_crtc_config ~(crtc : crtc) ~(timestamp : Xproto.timestamp) ~(config_timestamp : Xproto.timestamp) ~(x : int) ~(y : int) ~(mode : mode) ~(rotation : rotation_mask) ~(outputs : output list) () : set_crtc_config_reply Lwt.t = failwith "not implemented";;
type get_crtc_gamma_size_reply = { size : int; };;
let get_crtc_gamma_size ~(crtc : crtc) () : get_crtc_gamma_size_reply Lwt.t = failwith "not implemented";;
type get_crtc_gamma_reply = { red : int list; green : int list; blue : int list; };;
let get_crtc_gamma ~(crtc : crtc) () : get_crtc_gamma_reply Lwt.t = failwith "not implemented";;
let set_crtc_gamma ~(crtc : crtc) ~(red : int list) ~(green : int list) ~(blue : int list) () : unit Lwt.t = failwith "not implemented";;
type get_screen_resources_current_reply = { timestamp : Xproto.timestamp; config_timestamp : Xproto.timestamp; crtcs : crtc list; outputs : output list; modes : mode_info list; names : char list; };;
let get_screen_resources_current ~(window : Xproto.window) () : get_screen_resources_current_reply Lwt.t = failwith "not implemented";;
type transform_mask = [ `Unit | `Scale_up | `Scale_down | `Projective ] list;;
let set_crtc_transform ~(crtc : crtc) ~(transform : Render.transform) ~(filter_name : char list) ~(filter_params : Render.fixed list) () : unit Lwt.t = failwith "not implemented";;
type get_crtc_transform_reply = { pending_transform : Render.transform; has_transforms : bool; current_transform : Render.transform; pending_filter_name : char list; pending_params : Render.fixed list; current_filter_name : char list; current_params : Render.fixed list; };;
let get_crtc_transform ~(crtc : crtc) () : get_crtc_transform_reply Lwt.t = failwith "not implemented";;
type get_panning_reply = { status : set_config_enum; timestamp : Xproto.timestamp; left : int; top : int; width : int; height : int; track_left : int; track_top : int; track_width : int; track_height : int; border_left : int; border_top : int; border_right : int; border_bottom : int; };;
let get_panning ~(crtc : crtc) () : get_panning_reply Lwt.t = failwith "not implemented";;
type set_panning_reply = { status : set_config_enum; timestamp : Xproto.timestamp; };;
let set_panning ~(crtc : crtc) ~(timestamp : Xproto.timestamp) ~(left : int) ~(top : int) ~(width : int) ~(height : int) ~(track_left : int) ~(track_top : int) ~(track_width : int) ~(track_height : int) ~(border_left : int) ~(border_top : int) ~(border_right : int) ~(border_bottom : int) () : set_panning_reply Lwt.t = failwith "not implemented";;
let set_output_primary ~(window : Xproto.window) ~(output : output) () : unit Lwt.t = failwith "not implemented";;
type get_output_primary_reply = { output : output; };;
let get_output_primary ~(window : Xproto.window) () : get_output_primary_reply Lwt.t = failwith "not implemented";;
type get_providers_reply = { timestamp : Xproto.timestamp; providers : provider list; };;
let get_providers ~(window : Xproto.window) () : get_providers_reply Lwt.t = failwith "not implemented";;
type provider_capability_mask = [ `Source_output | `Sink_output | `Source_offload | `Sink_offload ] list;;
type get_provider_info_reply = { status : int; timestamp : Xproto.timestamp; capabilities : provider_capability_mask; crtcs : crtc list; outputs : output list; associated_providers : provider list; associated_capability : int32 list; name : char list; };;
let get_provider_info ~(provider : provider) ~(config_timestamp : Xproto.timestamp) () : get_provider_info_reply Lwt.t = failwith "not implemented";;
let set_provider_offload_sink ~(provider : provider) ~(sink_provider : provider) ~(config_timestamp : Xproto.timestamp) () : unit Lwt.t = failwith "not implemented";;
let set_provider_output_source ~(provider : provider) ~(source_provider : provider) ~(config_timestamp : Xproto.timestamp) () : unit Lwt.t = failwith "not implemented";;
type list_provider_properties_reply = { atoms : Xproto.atom list; };;
let list_provider_properties ~(provider : provider) () : list_provider_properties_reply Lwt.t = failwith "not implemented";;
type query_provider_property_reply = { pending : bool; range : bool; immutable : bool; valid_values : int32 list; };;
let query_provider_property ~(provider : provider) ~(property : Xproto.atom) () : query_provider_property_reply Lwt.t = failwith "not implemented";;
let configure_provider_property ~(provider : provider) ~(property : Xproto.atom) ~(pending : bool) ~(range : bool) ~(values : int32 list) () : unit Lwt.t = failwith "not implemented";;
let change_provider_property ~(provider : provider) ~(property : Xproto.atom) ~(type_ : Xproto.atom) ~(format : int) ~(mode : int) ~(num_items : int32) ~(data : char list) () : unit Lwt.t = failwith "not implemented";;
let delete_provider_property ~(provider : provider) ~(property : Xproto.atom) () : unit Lwt.t = failwith "not implemented";;
type get_provider_property_reply = { format : int; type_ : Xproto.atom; bytes_after : int32; num_items : int32; data : char list; };;
let get_provider_property ~(provider : provider) ~(property : Xproto.atom) ~(type_ : Xproto.atom) ~(long_offset : int32) ~(long_length : int32) ~(delete : bool) ~(pending : bool) () : get_provider_property_reply Lwt.t = failwith "not implemented";;
type screen_change_notify_event = { rotation : rotation_mask; timestamp : Xproto.timestamp; config_timestamp : Xproto.timestamp; root : Xproto.window; request_window : Xproto.window; size_id : int; subpixel_order : Render.sub_pixel_enum; width : int; height : int; mwidth : int; mheight : int; };;
type notify_enum = Crtc_change | Output_change | Output_property | Provider_change | Provider_property | Resource_change | Lease;;
type crtc_change = { timestamp : Xproto.timestamp; window : Xproto.window; crtc : crtc; mode : mode; rotation : rotation_mask; x : int; y : int; width : int; height : int; };;
type output_change = { timestamp : Xproto.timestamp; config_timestamp : Xproto.timestamp; window : Xproto.window; output : output; crtc : crtc; mode : mode; rotation : rotation_mask; connection : connection_enum; subpixel_order : Render.sub_pixel_enum; };;
type output_property = { window : Xproto.window; output : output; atom : Xproto.atom; timestamp : Xproto.timestamp; status : Xproto.property_enum; };;
type provider_change = { timestamp : Xproto.timestamp; window : Xproto.window; provider : provider; };;
type provider_property = { window : Xproto.window; provider : provider; atom : Xproto.atom; timestamp : Xproto.timestamp; state : int; };;
type resource_change = { timestamp : Xproto.timestamp; window : Xproto.window; };;
type monitor_info = { name : Xproto.atom; primary : bool; automatic : bool; x : int; y : int; width : int; height : int; width_in_millimeters : int32; height_in_millimeters : int32; outputs : output list; };;
type get_monitors_reply = { timestamp : Xproto.timestamp; n_outputs : int32; monitors : monitor_info list; };;
let get_monitors ~(window : Xproto.window) ~(get_active : bool) () : get_monitors_reply Lwt.t = failwith "not implemented";;
let set_monitor ~(window : Xproto.window) ~(monitorinfo : monitor_info) () : unit Lwt.t = failwith "not implemented";;
let delete_monitor ~(window : Xproto.window) ~(name : Xproto.atom) () : unit Lwt.t = failwith "not implemented";;
type create_lease_reply = { nfd : int; master_fd : file_descr; };;
let create_lease ~(window : Xproto.window) ~(lid : lease) ~(crtcs : crtc list) ~(outputs : output list) () : create_lease_reply Lwt.t = failwith "not implemented";;
let free_lease ~(lid : lease) ~(terminate : char) () : unit Lwt.t = failwith "not implemented";;
type lease_notify = { timestamp : Xproto.timestamp; window : Xproto.window; lease : lease; created : int; };;
type notify_variant = Crtc_change of { cc : crtc_change; } | Output_change of { oc : output_change; } | Output_property of { op : output_property; } | Provider_change of { pc : provider_change; } | Provider_property of { pp : provider_property; } | Resource_change of { rc : resource_change; } | Lease of { lc : lease_notify; };;
type notify_event = { u : notify_variant; };;
end
module[@warning "-27"] Sync = struct
type alarm = xid;;
type alarmstate_enum = Active | Inactive | Destroyed;;
type counter = xid;;
type fence = xid;;
type testtype_enum = Positive_transition | Negative_transition | Positive_comparison | Negative_comparison;;
type valuetype_enum = Absolute | Relative;;
type ca_mask = [ `Counter | `Value_type | `Value | `Test_type | `Delta | `Events ] list;;
type int64 = { hi : int32; lo : int32; };;
type systemcounter = { counter : counter; resolution : int64; name : char list; };;
type trigger = { counter : counter; wait_type : valuetype_enum; wait_value : int64; test_type : testtype_enum; };;
type waitcondition = { trigger : trigger; event_threshold : int64; };;
type counter_error = { bad_counter : int32; minor_opcode : int; major_opcode : int; };;
type alarm_error = { bad_alarm : int32; minor_opcode : int; major_opcode : int; };;
type initialize_reply = { major_version : int; minor_version : int; };;
let initialize ~(desired_major_version : int) ~(desired_minor_version : int) () : initialize_reply Lwt.t = failwith "not implemented";;
type list_system_counters_reply = { counters : systemcounter list; };;
let list_system_counters () : list_system_counters_reply Lwt.t = failwith "not implemented";;
let create_counter ~(id : counter) ~(initial_value : int64) () : unit Lwt.t = failwith "not implemented";;
let destroy_counter ~(counter : counter) () : unit Lwt.t = failwith "not implemented";;
type query_counter_reply = { counter_value : int64; };;
let query_counter ~(counter : counter) () : query_counter_reply Lwt.t = failwith "not implemented";;
let await ~(wait_list : waitcondition list) () : unit Lwt.t = failwith "not implemented";;
let change_counter ~(counter : counter) ~(amount : int64) () : unit Lwt.t = failwith "not implemented";;
let set_counter ~(counter : counter) ~(value : int64) () : unit Lwt.t = failwith "not implemented";;
let create_alarm ~(id : alarm) ?(counter : counter option) ?(value_type : valuetype_enum option) ?(value : int64 option) ?(test_type : testtype_enum option) ?(delta : int64 option) ?(events : int32 option) () : unit Lwt.t = failwith "not implemented";;
let change_alarm ~(id : alarm) ?(counter : counter option) ?(value_type : valuetype_enum option) ?(value : int64 option) ?(test_type : testtype_enum option) ?(delta : int64 option) ?(events : int32 option) () : unit Lwt.t = failwith "not implemented";;
let destroy_alarm ~(alarm : alarm) () : unit Lwt.t = failwith "not implemented";;
type query_alarm_reply = { trigger : trigger; delta : int64; events : bool; state : alarmstate_enum; };;
let query_alarm ~(alarm : alarm) () : query_alarm_reply Lwt.t = failwith "not implemented";;
let set_priority ~(id : int32) ~(priority : int32) () : unit Lwt.t = failwith "not implemented";;
type get_priority_reply = { priority : int32; };;
let get_priority ~(id : int32) () : get_priority_reply Lwt.t = failwith "not implemented";;
let create_fence ~(drawable : Xproto.drawable) ~(fence : fence) ~(initially_triggered : bool) () : unit Lwt.t = failwith "not implemented";;
let trigger_fence ~(fence : fence) () : unit Lwt.t = failwith "not implemented";;
let reset_fence ~(fence : fence) () : unit Lwt.t = failwith "not implemented";;
let destroy_fence ~(fence : fence) () : unit Lwt.t = failwith "not implemented";;
type query_fence_reply = { triggered : bool; };;
let query_fence ~(fence : fence) () : query_fence_reply Lwt.t = failwith "not implemented";;
let await_fence ~(fence_list : fence list) () : unit Lwt.t = failwith "not implemented";;
type counter_notify_event = { kind : int; counter : counter; wait_value : int64; counter_value : int64; timestamp : Xproto.timestamp; count : int; destroyed : bool; };;
type alarm_notify_event = { kind : int; alarm : alarm; counter_value : int64; alarm_value : int64; timestamp : Xproto.timestamp; state : alarmstate_enum; };;
end
module[@warning "-27"] Present = struct
type event_enum = Configure_notify | Complete_notify | Idle_notify | Redirect_notify;;
type event_mask_mask = ([ `Configure_notify | `Complete_notify | `Idle_notify | `Redirect_notify ], [ `No_event ]) mask;;
type option_mask = ([ `Async | `Copy | `Ust | `Suboptimal ], [ `None ]) mask;;
type capability_mask = ([ `Async | `Fence | `Ust ], [ `None ]) mask;;
type complete_kind_enum = Pixmap | Notify_msc;;
type complete_mode_enum = Copy | Flip | Skip | Suboptimal_copy;;
type notify = { window : Xproto.window; serial : int32; };;
type query_version_reply = { major_version : int32; minor_version : int32; };;
let query_version ~(major_version : int32) ~(minor_version : int32) () : query_version_reply Lwt.t = failwith "not implemented";;
let pixmap ~(window : Xproto.window) ~(pixmap : Xproto.pixmap) ~(serial : int32) ~(valid : Xfixes.region) ~(update : Xfixes.region) ~(x_off : int) ~(y_off : int) ~(target_crtc : Randr.crtc) ~(wait_fence : Sync.fence) ~(idle_fence : Sync.fence) ~(options : int32) ~(target_msc : int64) ~(divisor : int64) ~(remainder : int64) ~(notifies : notify list) () : unit Lwt.t = failwith "not implemented";;
let notify_msc ~(window : Xproto.window) ~(serial : int32) ~(target_msc : int64) ~(divisor : int64) ~(remainder : int64) () : unit Lwt.t = failwith "not implemented";;
type event = xid;;
let select_input ~(eid : event) ~(window : Xproto.window) ~(event_mask : event_mask_mask) () : unit Lwt.t = failwith "not implemented";;
type query_capabilities_reply = { capabilities : int32; };;
let query_capabilities ~(target : int32) () : query_capabilities_reply Lwt.t = failwith "not implemented";;
type generic_event = { extension : int; length : int32; evtype : int; event : event; };;
type configure_notify_event = { event : event; window : Xproto.window; x : int; y : int; width : int; height : int; off_x : int; off_y : int; pixmap_width : int; pixmap_height : int; pixmap_flags : int32; };;
type complete_notify_event = { kind : complete_kind_enum; mode : complete_mode_enum; event : event; window : Xproto.window; serial : int32; ust : int64; msc : int64; };;
type idle_notify_event = { event : event; window : Xproto.window; serial : int32; pixmap : Xproto.pixmap; idle_fence : Sync.fence; };;
type redirect_notify_event = { update_window : bool; event : event; event_window : Xproto.window; window : Xproto.window; pixmap : Xproto.pixmap; serial : int32; valid_region : Xfixes.region; update_region : Xfixes.region; valid_rect : Xproto.rectangle; update_rect : Xproto.rectangle; x_off : int; y_off : int; target_crtc : Randr.crtc; wait_fence : Sync.fence; idle_fence : Sync.fence; options : int32; target_msc : int64; divisor : int64; remainder : int64; notifies : notify list; };;
end
module[@warning "-27"] Record = struct
type context = xid;;
type range8 = { first : int; last : int; };;
type range16 = { first : int; last : int; };;
type ext_range = { major : range8; minor : range16; };;
type range = { core_requests : range8; core_replies : range8; ext_requests : ext_range; ext_replies : ext_range; delivered_events : range8; device_events : range8; errors : range8; client_started : bool; client_died : bool; };;
type element_header = int;;
type h_type_mask = [ `From_server_time | `From_client_time | `From_client_sequence ] list;;
type client_spec = int32;;
type cs_enum = Current_clients | Future_clients | All_clients;;
type client_info = { client_resource : client_spec; ranges : range list; };;
type bad_context_error = { invalid_record : int32; };;
type query_version_reply = { major_version : int; minor_version : int; };;
let query_version ~(major_version : int) ~(minor_version : int) () : query_version_reply Lwt.t = failwith "not implemented";;
let create_context ~(context : context) ~(element_header : element_header) ~(client_specs : client_spec list) ~(ranges : range list) () : unit Lwt.t = failwith "not implemented";;
let register_clients ~(context : context) ~(element_header : element_header) ~(client_specs : client_spec list) ~(ranges : range list) () : unit Lwt.t = failwith "not implemented";;
let unregister_clients ~(context : context) ~(client_specs : client_spec list) () : unit Lwt.t = failwith "not implemented";;
type get_context_reply = { enabled : bool; element_header : element_header; intercepted_clients : client_info list; };;
let get_context ~(context : context) () : get_context_reply Lwt.t = failwith "not implemented";;
type enable_context_reply = { category : int; element_header : element_header; client_swapped : bool; xid_base : int32; server_time : int32; rec_sequence_num : int32; data : char list; };;
let enable_context ~(context : context) () : enable_context_reply Lwt.t = failwith "not implemented";;
let disable_context ~(context : context) () : unit Lwt.t = failwith "not implemented";;
let free_context ~(context : context) () : unit Lwt.t = failwith "not implemented";;
end
module[@warning "-27"] Res = struct
type client = { resource_base : int32; resource_mask : int32; };;
type type_ = { resource_type : Xproto.atom; count : int32; };;
type client_id_mask_mask = [ `Client_xid | `Local_client_pid ] list;;
type client_id_spec = { client : int32; mask : client_id_mask_mask; };;
type client_id_value = { spec : client_id_spec; length : int32; value : int32 list; };;
type resource_id_spec = { resource : int32; type_ : int32; };;
type resource_size_spec = { spec : resource_id_spec; bytes : int32; ref_count : int32; use_count : int32; };;
type resource_size_value = { size : resource_size_spec; cross_references : resource_size_spec list; };;
type query_version_reply = { server_major : int; server_minor : int; };;
let query_version ~(client_major : int) ~(client_minor : int) () : query_version_reply Lwt.t = failwith "not implemented";;
type query_clients_reply = { clients : client list; };;
let query_clients () : query_clients_reply Lwt.t = failwith "not implemented";;
type query_client_resources_reply = { types : type_ list; };;
let query_client_resources ~(xid : int32) () : query_client_resources_reply Lwt.t = failwith "not implemented";;
type query_client_pixmap_bytes_reply = { bytes : int32; bytes_overflow : int32; };;
let query_client_pixmap_bytes ~(xid : int32) () : query_client_pixmap_bytes_reply Lwt.t = failwith "not implemented";;
type query_client_ids_reply = { ids : client_id_value list; };;
let query_client_ids ~(specs : client_id_spec list) () : query_client_ids_reply Lwt.t = failwith "not implemented";;
type query_resource_bytes_reply = { sizes : resource_size_value list; };;
let query_resource_bytes ~(client : int32) ~(specs : resource_id_spec list) () : query_resource_bytes_reply Lwt.t = failwith "not implemented";;
end
module[@warning "-27"] Screensaver = struct
type kind_enum = Blanked | Internal | External;;
type event_mask = [ `Notify_mask | `Cycle_mask ] list;;
type state_enum = Off | On | Cycle | Disabled;;
type query_version_reply = { server_major_version : int; server_minor_version : int; };;
let query_version ~(client_major_version : int) ~(client_minor_version : int) () : query_version_reply Lwt.t = failwith "not implemented";;
type query_info_reply = { state : int; saver_window : Xproto.window; ms_until_server : int32; ms_since_user_input : int32; event_mask : int32; kind : kind_enum; };;
let query_info ~(drawable : Xproto.drawable) () : query_info_reply Lwt.t = failwith "not implemented";;
let select_input ~(drawable : Xproto.drawable) ~(event_mask : event_mask) () : unit Lwt.t = failwith "not implemented";;
let set_attributes ~(drawable : Xproto.drawable) ~(x : int) ~(y : int) ~(width : int) ~(height : int) ~(border_width : int) ~(class_ : Xproto.window_class_enum) ~(depth : int) ~(visual : Xproto.visualid) ?(background_pixmap : (Xproto.back_pixmap_enum, Xproto.pixmap) alt option) ?(background_pixel : int32 option) ?(border_pixmap : (Xproto.pixmap_enum, Xproto.pixmap) alt option) ?(border_pixel : int32 option) ?(bit_gravity : Xproto.gravity_enum option) ?(win_gravity : Xproto.gravity_enum option) ?(backing_store : Xproto.backing_store_enum option) ?(backing_planes : int32 option) ?(backing_pixel : int32 option) ?(override_redirect : Xproto.bool32 option) ?(save_under : Xproto.bool32 option) ?(event_mask : Xproto.event_mask_mask option) ?(do_not_propogate_mask : Xproto.event_mask_mask option) ?(colormap : (Xproto.colormap_enum, Xproto.colormap) alt option) ?(cursor : (Xproto.cursor_enum, Xproto.cursor) alt option) () : unit Lwt.t = failwith "not implemented";;
let unset_attributes ~(drawable : Xproto.drawable) () : unit Lwt.t = failwith "not implemented";;
let suspend ~(suspend : int32) () : unit Lwt.t = failwith "not implemented";;
type notify_event = { state : state_enum; time : Xproto.timestamp; root : Xproto.window; window : Xproto.window; kind : kind_enum; forced : bool; };;
end
module[@warning "-27"] Shm = struct
type seg = xid;;
type completion_event = { drawable : Xproto.drawable; minor_event : int; major_event : char; shmseg : seg; offset : int32; };;
type bad_seg_error = Xproto.value_error;;
type query_version_reply = { shared_pixmaps : bool; major_version : int; minor_version : int; uid : int; gid : int; pixmap_format : int; };;
let query_version () : query_version_reply Lwt.t = failwith "not implemented";;
let attach ~(shmseg : seg) ~(shmid : int32) ~(read_only : bool) () : unit Lwt.t = failwith "not implemented";;
let detach ~(shmseg : seg) () : unit Lwt.t = failwith "not implemented";;
let put_image ~(drawable : Xproto.drawable) ~(gc : Xproto.gcontext) ~(total_width : int) ~(total_height : int) ~(src_x : int) ~(src_y : int) ~(src_width : int) ~(src_height : int) ~(dst_x : int) ~(dst_y : int) ~(depth : int) ~(format : int) ~(send_event : bool) ~(shmseg : seg) ~(offset : int32) () : unit Lwt.t = failwith "not implemented";;
type get_image_reply = { depth : int; visual : Xproto.visualid; size : int32; };;
let get_image ~(drawable : Xproto.drawable) ~(x : int) ~(y : int) ~(width : int) ~(height : int) ~(plane_mask : int32) ~(format : int) ~(shmseg : seg) ~(offset : int32) () : get_image_reply Lwt.t = failwith "not implemented";;
let create_pixmap ~(pid : Xproto.pixmap) ~(drawable : Xproto.drawable) ~(width : int) ~(height : int) ~(depth : int) ~(shmseg : seg) ~(offset : int32) () : unit Lwt.t = failwith "not implemented";;
let attach_fd ~(shmseg : seg) ~(shm_fd : file_descr) ~(read_only : bool) () : unit Lwt.t = failwith "not implemented";;
type create_segment_reply = { nfd : int; shm_fd : file_descr; };;
let create_segment ~(shmseg : seg) ~(size : int32) ~(read_only : bool) () : create_segment_reply Lwt.t = failwith "not implemented";;
end
module[@warning "-27"] Xc_misc = struct
type get_version_reply = { server_major_version : int; server_minor_version : int; };;
let get_version ~(client_major_version : int) ~(client_minor_version : int) () : get_version_reply Lwt.t = failwith "not implemented";;
type get_xid_range_reply = { start_id : int32; count : int32; };;
let get_xid_range () : get_xid_range_reply Lwt.t = failwith "not implemented";;
type get_xid_list_reply = { ids : int32 list; };;
let get_xid_list ~(count : int32) () : get_xid_list_reply Lwt.t = failwith "not implemented";;
end
module[@warning "-27"] Xf86dri = struct
type drm_clip_rect = { x1 : int; y1 : int; x2 : int; x3 : int; };;
type query_version_reply = { dri_major_version : int; dri_minor_version : int; dri_minor_patch : int32; };;
let query_version () : query_version_reply Lwt.t = failwith "not implemented";;
type query_direct_rendering_capable_reply = { is_capable : bool; };;
let query_direct_rendering_capable ~(screen : int32) () : query_direct_rendering_capable_reply Lwt.t = failwith "not implemented";;
type open_connection_reply = { sarea_handle_low : int32; sarea_handle_high : int32; bus_id : char list; };;
let open_connection ~(screen : int32) () : open_connection_reply Lwt.t = failwith "not implemented";;
let close_connection ~(screen : int32) () : unit Lwt.t = failwith "not implemented";;
type get_client_driver_name_reply = { client_driver_major_version : int32; client_driver_minor_version : int32; client_driver_patch_version : int32; client_driver_name : char list; };;
let get_client_driver_name ~(screen : int32) () : get_client_driver_name_reply Lwt.t = failwith "not implemented";;
type create_context_reply = { hw_context : int32; };;
let create_context ~(screen : int32) ~(visual : int32) ~(context : int32) () : create_context_reply Lwt.t = failwith "not implemented";;
let destroy_context ~(screen : int32) ~(context : int32) () : unit Lwt.t = failwith "not implemented";;
type create_drawable_reply = { hw_drawable_handle : int32; };;
let create_drawable ~(screen : int32) ~(drawable : int32) () : create_drawable_reply Lwt.t = failwith "not implemented";;
let destroy_drawable ~(screen : int32) ~(drawable : int32) () : unit Lwt.t = failwith "not implemented";;
type get_drawable_info_reply = { drawable_table_index : int32; drawable_table_stamp : int32; drawable_origin_x : int; drawable_origin_y : int; drawable_size_w : int; drawable_size_h : int; back_x : int; back_y : int; clip_rects : drm_clip_rect list; back_clip_rects : drm_clip_rect list; };;
let get_drawable_info ~(screen : int32) ~(drawable : int32) () : get_drawable_info_reply Lwt.t = failwith "not implemented";;
type get_device_info_reply = { framebuffer_handle_low : int32; framebuffer_handle_high : int32; framebuffer_origin_offset : int32; framebuffer_size : int32; framebuffer_stride : int32; device_private : int32 list; };;
let get_device_info ~(screen : int32) () : get_device_info_reply Lwt.t = failwith "not implemented";;
type auth_connection_reply = { authenticated : int32; };;
let auth_connection ~(screen : int32) ~(magic : int32) () : auth_connection_reply Lwt.t = failwith "not implemented";;
end
module[@warning "-27"] Xf86vidmode = struct
type syncrange = int32;;
type dotclock = int32;;
type mode_flag_mask = [ `Positive_h_sync | `Negative_h_sync | `Positive_v_sync | `Negative_v_sync | `Interlace | `Composite_sync | `Positive_c_sync | `Negative_c_sync | `H_skew | `Broadcast | `Pixmux | `Double_clock | `Half_clock ] list;;
type clock_flag_mask = [ `Programable ] list;;
type permission_mask = [ `Read | `Write ] list;;
type mode_info = { dotclock : dotclock; hdisplay : int; hsyncstart : int; hsyncend : int; htotal : int; hskew : int32; vdisplay : int; vsyncstart : int; vsyncend : int; vtotal : int; flags : mode_flag_mask; privsize : int32; };;
type query_version_reply = { major_version : int; minor_version : int; };;
let query_version () : query_version_reply Lwt.t = failwith "not implemented";;
type get_mode_line_reply = { dotclock : dotclock; hdisplay : int; hsyncstart : int; hsyncend : int; htotal : int; hskew : int; vdisplay : int; vsyncstart : int; vsyncend : int; vtotal : int; flags : mode_flag_mask; private_ : int list; };;
let get_mode_line ~(screen : int) () : get_mode_line_reply Lwt.t = failwith "not implemented";;
let mod_mode_line ~(screen : int32) ~(hdisplay : int) ~(hsyncstart : int) ~(hsyncend : int) ~(htotal : int) ~(hskew : int) ~(vdisplay : int) ~(vsyncstart : int) ~(vsyncend : int) ~(vtotal : int) ~(flags : mode_flag_mask) ~(private_ : int list) () : unit Lwt.t = failwith "not implemented";;
let switch_mode ~(screen : int) ~(zoom : int) () : unit Lwt.t = failwith "not implemented";;
type get_monitor_reply = { hsync : syncrange list; vsync : syncrange list; vendor : char list; alignment_pad : char list; model : char list; };;
let get_monitor ~(screen : int) () : get_monitor_reply Lwt.t = failwith "not implemented";;
let lock_mode_switch ~(screen : int) ~(lock : int) () : unit Lwt.t = failwith "not implemented";;
type get_all_mode_lines_reply = { modeinfo : mode_info list; };;
let get_all_mode_lines ~(screen : int) () : get_all_mode_lines_reply Lwt.t = failwith "not implemented";;
let add_mode_line ~(screen : int32) ~(dotclock : dotclock) ~(hdisplay : int) ~(hsyncstart : int) ~(hsyncend : int) ~(htotal : int) ~(hskew : int) ~(vdisplay : int) ~(vsyncstart : int) ~(vsyncend : int) ~(vtotal : int) ~(flags : mode_flag_mask) ~(after_dotclock : dotclock) ~(after_hdisplay : int) ~(after_hsyncstart : int) ~(after_hsyncend : int) ~(after_htotal : int) ~(after_hskew : int) ~(after_vdisplay : int) ~(after_vsyncstart : int) ~(after_vsyncend : int) ~(after_vtotal : int) ~(after_flags : mode_flag_mask) ~(private_ : int list) () : unit Lwt.t = failwith "not implemented";;
let delete_mode_line ~(screen : int32) ~(dotclock : dotclock) ~(hdisplay : int) ~(hsyncstart : int) ~(hsyncend : int) ~(htotal : int) ~(hskew : int) ~(vdisplay : int) ~(vsyncstart : int) ~(vsyncend : int) ~(vtotal : int) ~(flags : mode_flag_mask) ~(private_ : int list) () : unit Lwt.t = failwith "not implemented";;
type validate_mode_line_reply = { status : int32; };;
let validate_mode_line ~(screen : int32) ~(dotclock : dotclock) ~(hdisplay : int) ~(hsyncstart : int) ~(hsyncend : int) ~(htotal : int) ~(hskew : int) ~(vdisplay : int) ~(vsyncstart : int) ~(vsyncend : int) ~(vtotal : int) ~(flags : mode_flag_mask) ~(private_ : int list) () : validate_mode_line_reply Lwt.t = failwith "not implemented";;
let switch_to_mode ~(screen : int32) ~(dotclock : dotclock) ~(hdisplay : int) ~(hsyncstart : int) ~(hsyncend : int) ~(htotal : int) ~(hskew : int) ~(vdisplay : int) ~(vsyncstart : int) ~(vsyncend : int) ~(vtotal : int) ~(flags : mode_flag_mask) ~(private_ : int list) () : unit Lwt.t = failwith "not implemented";;
type get_view_port_reply = { x : int32; y : int32; };;
let get_view_port ~(screen : int) () : get_view_port_reply Lwt.t = failwith "not implemented";;
let set_view_port ~(screen : int) ~(x : int32) ~(y : int32) () : unit Lwt.t = failwith "not implemented";;
type get_dot_clocks_reply = { flags : clock_flag_mask; clocks : int32; maxclocks : int32; clock : int32 list; };;
let get_dot_clocks ~(screen : int) () : get_dot_clocks_reply Lwt.t = failwith "not implemented";;
let set_client_version ~(major : int) ~(minor : int) () : unit Lwt.t = failwith "not implemented";;
let set_gamma ~(screen : int) ~(red : int32) ~(green : int32) ~(blue : int32) () : unit Lwt.t = failwith "not implemented";;
type get_gamma_reply = { red : int32; green : int32; blue : int32; };;
let get_gamma ~(screen : int) () : get_gamma_reply Lwt.t = failwith "not implemented";;
type get_gamma_ramp_reply = { size : int; red : int list; green : int list; blue : int list; };;
let get_gamma_ramp ~(screen : int) ~(size : int) () : get_gamma_ramp_reply Lwt.t = failwith "not implemented";;
let set_gamma_ramp ~(screen : int) ~(size : int) ~(red : int list) ~(green : int list) ~(blue : int list) () : unit Lwt.t = failwith "not implemented";;
type get_gamma_ramp_size_reply = { size : int; };;
let get_gamma_ramp_size ~(screen : int) () : get_gamma_ramp_size_reply Lwt.t = failwith "not implemented";;
type get_permissions_reply = { permissions : permission_mask; };;
let get_permissions ~(screen : int) () : get_permissions_reply Lwt.t = failwith "not implemented";;
type bad_clock_error = unit;;
type bad_h_timings_error = unit;;
type bad_v_timings_error = unit;;
type mode_unsuitable_error = unit;;
type extension_disabled_error = unit;;
type client_not_local_error = unit;;
type zoom_locked_error = unit;;
end
module[@warning "-27"] Xinerama = struct
type screen_info = { x_org : int; y_org : int; width : int; height : int; };;
type query_version_reply = { major : int; minor : int; };;
let query_version ~(major : int) ~(minor : int) () : query_version_reply Lwt.t = failwith "not implemented";;
type get_state_reply = { state : char; window : Xproto.window; };;
let get_state ~(window : Xproto.window) () : get_state_reply Lwt.t = failwith "not implemented";;
type get_screen_count_reply = { screen_count : char; window : Xproto.window; };;
let get_screen_count ~(window : Xproto.window) () : get_screen_count_reply Lwt.t = failwith "not implemented";;
type get_screen_size_reply = { width : int32; height : int32; window : Xproto.window; screen : int32; };;
let get_screen_size ~(window : Xproto.window) ~(screen : int32) () : get_screen_size_reply Lwt.t = failwith "not implemented";;
type is_active_reply = { state : int32; };;
let is_active () : is_active_reply Lwt.t = failwith "not implemented";;
type query_screens_reply = { screen_info : screen_info list; };;
let query_screens () : query_screens_reply Lwt.t = failwith "not implemented";;
end
module[@warning "-27"] Xinput = struct
type event_class = int32;;
type key_code = int;;
type device_id = int;;
type fp1616 = int32;;
type fp3232 = { integral : int32; frac : int32; };;
type get_extension_version_reply = { xi_reply_type : int; server_major : int; server_minor : int; present : bool; };;
let get_extension_version ~(name : char list) () : get_extension_version_reply Lwt.t = failwith "not implemented";;
type device_use_enum = Is_x_pointer | Is_x_keyboard | Is_x_extension_device | Is_x_extension_keyboard | Is_x_extension_pointer;;
type input_class_enum = Key | Button | Valuator | Feedback | Proximity | Focus | Other;;
type valuator_mode_enum = Relative | Absolute;;
type device_info = { device_type : Xproto.atom; device_id : int; num_class_info : int; device_use : device_use_enum; };;
type key_info = { class_id : input_class_enum; len : int; min_keycode : key_code; max_keycode : key_code; num_keys : int; };;
type button_info = { class_id : input_class_enum; len : int; num_buttons : int; };;
type axis_info = { resolution : int32; minimum : int32; maximum : int32; };;
type valuator_info = { class_id : input_class_enum; len : int; mode : valuator_mode_enum; motion_size : int32; axes : axis_info list; };;
type input_class_variant = Key of { min_keycode : key_code; max_keycode : key_code; num_keys : int; } | Button of { num_buttons : int; } | Valuator of { mode : valuator_mode_enum; motion_size : int32; axes : axis_info list; };;
type input_info = { len : int; info : input_class_variant; };;
type device_name = { string : char list; };;
type list_input_devices_reply = { xi_reply_type : int; devices : device_info list; infos : input_info list; names : Xproto.str list; };;
let list_input_devices () : list_input_devices_reply Lwt.t = failwith "not implemented";;
type event_type_base = int;;
type input_class_info = { class_id : input_class_enum; event_type_base : event_type_base; };;
type open_device_reply = { xi_reply_type : int; class_info : input_class_info list; };;
let open_device ~(device_id : int) () : open_device_reply Lwt.t = failwith "not implemented";;
let close_device ~(device_id : int) () : unit Lwt.t = failwith "not implemented";;
type set_device_mode_reply = { xi_reply_type : int; status : Xproto.grab_status_enum; };;
let set_device_mode ~(device_id : int) ~(mode : valuator_mode_enum) () : set_device_mode_reply Lwt.t = failwith "not implemented";;
let select_extension_event ~(window : Xproto.window) ~(classes : event_class list) () : unit Lwt.t = failwith "not implemented";;
type get_selected_extension_events_reply = { xi_reply_type : int; this_classes : event_class list; all_classes : event_class list; };;
let get_selected_extension_events ~(window : Xproto.window) () : get_selected_extension_events_reply Lwt.t = failwith "not implemented";;
type propagate_mode_enum = Add_to_list | Delete_from_list;;
let change_device_dont_propagate_list ~(window : Xproto.window) ~(mode : propagate_mode_enum) ~(classes : event_class list) () : unit Lwt.t = failwith "not implemented";;
type get_device_dont_propagate_list_reply = { xi_reply_type : int; classes : event_class list; };;
let get_device_dont_propagate_list ~(window : Xproto.window) () : get_device_dont_propagate_list_reply Lwt.t = failwith "not implemented";;
type device_time_coord = { time : Xproto.timestamp; axisvalues : int32 list; };;
type get_device_motion_events_reply = { xi_reply_type : int; num_axes : int; device_mode : valuator_mode_enum; events : device_time_coord list; };;
let get_device_motion_events ~(start : Xproto.timestamp) ~(stop : (Xproto.time_enum, Xproto.timestamp) alt) ~(device_id : int) () : get_device_motion_events_reply Lwt.t = failwith "not implemented";;
type change_keyboard_device_reply = { xi_reply_type : int; status : Xproto.grab_status_enum; };;
let change_keyboard_device ~(device_id : int) () : change_keyboard_device_reply Lwt.t = failwith "not implemented";;
type change_pointer_device_reply = { xi_reply_type : int; status : Xproto.grab_status_enum; };;
let change_pointer_device ~(x_axis : int) ~(y_axis : int) ~(device_id : int) () : change_pointer_device_reply Lwt.t = failwith "not implemented";;
type grab_device_reply = { xi_reply_type : int; status : Xproto.grab_status_enum; };;
let grab_device ~(grab_window : Xproto.window) ~(time : (Xproto.time_enum, Xproto.timestamp) alt) ~(this_device_mode : Xproto.grab_mode_enum) ~(other_device_mode : Xproto.grab_mode_enum) ~(owner_events : bool) ~(device_id : int) ~(classes : event_class list) () : grab_device_reply Lwt.t = failwith "not implemented";;
let ungrab_device ~(time : (Xproto.time_enum, Xproto.timestamp) alt) ~(device_id : int) () : unit Lwt.t = failwith "not implemented";;
type modifier_device_enum = Use_x_keyboard;;
let grab_device_key ~(grab_window : Xproto.window) ~(modifiers : Xproto.mod_mask_mask) ~(modifier_device : (modifier_device_enum, int) alt) ~(grabbed_device : int) ~(key : (Xproto.grab_enum, int) alt) ~(this_device_mode : Xproto.grab_mode_enum) ~(other_device_mode : Xproto.grab_mode_enum) ~(owner_events : bool) ~(classes : event_class list) () : unit Lwt.t = failwith "not implemented";;
let ungrab_device_key ~(grab_window : Xproto.window) ~(modifiers : Xproto.mod_mask_mask) ~(modifier_device : (modifier_device_enum, int) alt) ~(key : (Xproto.grab_enum, int) alt) ~(grabbed_device : int) () : unit Lwt.t = failwith "not implemented";;
let grab_device_button ~(grab_window : Xproto.window) ~(grabbed_device : int) ~(modifier_device : (modifier_device_enum, int) alt) ~(modifiers : Xproto.mod_mask_mask) ~(this_device_mode : Xproto.grab_mode_enum) ~(other_device_mode : Xproto.grab_mode_enum) ~(button : (Xproto.grab_enum, int) alt) ~(owner_events : bool) ~(classes : event_class list) () : unit Lwt.t = failwith "not implemented";;
let ungrab_device_button ~(grab_window : Xproto.window) ~(modifiers : Xproto.mod_mask_mask) ~(modifier_device : (modifier_device_enum, int) alt) ~(button : (Xproto.grab_enum, int) alt) ~(grabbed_device : int) () : unit Lwt.t = failwith "not implemented";;
type device_input_mode_enum = Async_this_device | Sync_this_device | Replay_this_device | Async_other_devices | Async_all | Sync_all;;
let allow_device_events ~(time : (Xproto.time_enum, Xproto.timestamp) alt) ~(mode : device_input_mode_enum) ~(device_id : int) () : unit Lwt.t = failwith "not implemented";;
type get_device_focus_reply = { xi_reply_type : int; focus : (Xproto.input_focus_enum, Xproto.window) alt; time : Xproto.timestamp; revert_to : Xproto.input_focus_enum; };;
let get_device_focus ~(device_id : int) () : get_device_focus_reply Lwt.t = failwith "not implemented";;
let set_device_focus ~(focus : (Xproto.input_focus_enum, Xproto.window) alt) ~(time : (Xproto.time_enum, Xproto.timestamp) alt) ~(revert_to : Xproto.input_focus_enum) ~(device_id : int) () : unit Lwt.t = failwith "not implemented";;
type feedback_class_enum = Keyboard | Pointer | String | Integer | Led | Bell;;
type kbd_feedback_state = { class_id : feedback_class_enum; feedback_id : int; len : int; pitch : int; duration : int; led_mask : int32; led_values : int32; global_auto_repeat : bool; click : int; percent : int; auto_repeats : int list; };;
type ptr_feedback_state = { class_id : feedback_class_enum; feedback_id : int; len : int; accel_num : int; accel_denom : int; threshold : int; };;
type integer_feedback_state = { class_id : feedback_class_enum; feedback_id : int; len : int; resolution : int32; min_value : int32; max_value : int32; };;
type string_feedback_state = { class_id : feedback_class_enum; feedback_id : int; len : int; max_symbols : int; keysyms : Xproto.keysym list; };;
type bell_feedback_state = { class_id : feedback_class_enum; feedback_id : int; len : int; percent : int; pitch : int; duration : int; };;
type led_feedback_state = { class_id : feedback_class_enum; feedback_id : int; len : int; led_mask : int32; led_values : int32; };;
type feedback_class_variant = Keyboard of { pitch : int; duration : int; led_mask : int32; led_values : int32; global_auto_repeat : bool; click : int; percent : int; auto_repeats : int list; } | Pointer of { accel_num : int; accel_denom : int; threshold : int; } | String of { max_symbols : int; keysyms : Xproto.keysym list; } | Integer of { resolution : int32; min_value : int32; max_value : int32; } | Led of { led_mask : int32; led_values : int32; } | Bell of { percent : int; pitch : int; duration : int; };;
type feedback_state = { feedback_id : int; len : int; data : feedback_class_variant; };;
type get_feedback_control_reply = { xi_reply_type : int; feedbacks : feedback_state list; };;
let get_feedback_control ~(device_id : int) () : get_feedback_control_reply Lwt.t = failwith "not implemented";;
type kbd_feedback_ctl = { class_id : feedback_class_enum; feedback_id : int; len : int; key : key_code; auto_repeat_mode : int; key_click_percent : int; bell_percent : int; bell_pitch : int; bell_duration : int; led_mask : int32; led_values : int32; };;
type ptr_feedback_ctl = { class_id : feedback_class_enum; feedback_id : int; len : int; num : int; denom : int; threshold : int; };;
type integer_feedback_ctl = { class_id : feedback_class_enum; feedback_id : int; len : int; int_to_display : int32; };;
type string_feedback_ctl = { class_id : feedback_class_enum; feedback_id : int; len : int; keysyms : Xproto.keysym list; };;
type bell_feedback_ctl = { class_id : feedback_class_enum; feedback_id : int; len : int; percent : int; pitch : int; duration : int; };;
type led_feedback_ctl = { class_id : feedback_class_enum; feedback_id : int; len : int; led_mask : int32; led_values : int32; };;
type feedback_ctl = { feedback_id : int; len : int; data : feedback_class_variant; };;
type change_feedback_control_mask_mask = [ `Key_click_percent | `Percent | `Pitch | `Duration | `Led | `Led_mode | `Key | `Auto_repeat_mode | `String | `Integer | `Accel_num | `Accel_denom | `Threshold ] list;;
let change_feedback_control ~(mask : change_feedback_control_mask_mask) ~(device_id : int) ~(feedback_id : int) ~(feedback : feedback_ctl) () : unit Lwt.t = failwith "not implemented";;
type get_device_key_mapping_reply = { xi_reply_type : int; keysyms_per_keycode : int; keysyms : Xproto.keysym list; };;
let get_device_key_mapping ~(device_id : int) ~(first_keycode : key_code) ~(count : int) () : get_device_key_mapping_reply Lwt.t = failwith "not implemented";;
let change_device_key_mapping ~(device_id : int) ~(first_keycode : key_code) ~(keysyms_per_keycode : int) ~(keycode_count : int) ~(keysyms : Xproto.keysym list) () : unit Lwt.t = failwith "not implemented";;
type get_device_modifier_mapping_reply = { xi_reply_type : int; keycodes_per_modifier : int; keymaps : int list; };;
let get_device_modifier_mapping ~(device_id : int) () : get_device_modifier_mapping_reply Lwt.t = failwith "not implemented";;
type set_device_modifier_mapping_reply = { xi_reply_type : int; status : Xproto.mapping_status_enum; };;
let set_device_modifier_mapping ~(device_id : int) ~(keycodes_per_modifier : int) ~(keymaps : int list) () : set_device_modifier_mapping_reply Lwt.t = failwith "not implemented";;
type get_device_button_mapping_reply = { xi_reply_type : int; map : int list; };;
let get_device_button_mapping ~(device_id : int) () : get_device_button_mapping_reply Lwt.t = failwith "not implemented";;
type set_device_button_mapping_reply = { xi_reply_type : int; status : Xproto.mapping_status_enum; };;
let set_device_button_mapping ~(device_id : int) ~(map : int list) () : set_device_button_mapping_reply Lwt.t = failwith "not implemented";;
type key_state = { class_id : input_class_enum; len : int; num_keys : int; keys : int list; };;
type button_state = { class_id : input_class_enum; len : int; num_buttons : int; buttons : int list; };;
type valuator_state_mode_mask_mask = [ `Device_mode_absolute | `Out_of_proximity ] list;;
type valuator_state = { class_id : input_class_enum; len : int; mode : valuator_state_mode_mask_mask; valuators : int32 list; };;
type input_state = { len : int; data : input_class_variant; };;
type query_device_state_reply = { xi_reply_type : int; classes : input_state list; };;
let query_device_state ~(device_id : int) () : query_device_state_reply Lwt.t = failwith "not implemented";;
let device_bell ~(device_id : int) ~(feedback_id : int) ~(feedback_class : int) ~(percent : int) () : unit Lwt.t = failwith "not implemented";;
type set_device_valuators_reply = { xi_reply_type : int; status : Xproto.grab_status_enum; };;
let set_device_valuators ~(device_id : int) ~(first_valuator : int) ~(valuators : int32 list) () : set_device_valuators_reply Lwt.t = failwith "not implemented";;
type device_control_enum = Resolution | Abs_calib | Core | Enable | Abs_area;;
type device_resolution_state = { control_id : device_control_enum; len : int; resolution_values : int32 list; resolution_min : int32 list; resolution_max : int32 list; };;
type device_abs_calib_state = { control_id : device_control_enum; len : int; min_x : int32; max_x : int32; min_y : int32; max_y : int32; flip_x : int32; flip_y : int32; rotation : int32; button_threshold : int32; };;
type device_abs_area_state = { control_id : device_control_enum; len : int; offset_x : int32; offset_y : int32; width : int32; height : int32; screen : int32; following : int32; };;
type device_core_state = { control_id : device_control_enum; len : int; status : int; iscore : int; };;
type device_enable_state = { control_id : device_control_enum; len : int; enable : int; };;
type device_control_variant = Resolution of { resolution_values : int32 list; resolution_min : int32 list; resolution_max : int32 list; } | Abs_calib of { min_x : int32; max_x : int32; min_y : int32; max_y : int32; flip_x : int32; flip_y : int32; rotation : int32; button_threshold : int32; } | Core of { status : int; iscore : int; } | Enable of { enable : int; } | Abs_area of { offset_x : int32; offset_y : int32; width : int32; height : int32; screen : int32; following : int32; };;
type device_state = { len : int; data : device_control_variant; };;
type get_device_control_reply = { xi_reply_type : int; status : (Xproto.grab_status_enum, int) alt; control : device_state; };;
let get_device_control ~(control_id : device_control_enum) ~(device_id : int) () : get_device_control_reply Lwt.t = failwith "not implemented";;
type device_resolution_ctl = { control_id : device_control_enum; len : int; first_valuator : int; resolution_values : int32 list; };;
type device_abs_calib_ctl = { control_id : device_control_enum; len : int; min_x : int32; max_x : int32; min_y : int32; max_y : int32; flip_x : int32; flip_y : int32; rotation : int32; button_threshold : int32; };;
type device_abs_area_ctrl = { control_id : device_control_enum; len : int; offset_x : int32; offset_y : int32; width : int32; height : int32; screen : int32; following : int32; };;
type device_core_ctrl = { control_id : device_control_enum; len : int; status : int; };;
type device_enable_ctrl = { control_id : device_control_enum; len : int; enable : int; };;
type device_ctl = { len : int; data : device_control_variant; };;
type change_device_control_reply = { xi_reply_type : int; status : (Xproto.grab_status_enum, int) alt; };;
let change_device_control ~(control_id : device_control_enum) ~(device_id : int) ~(control : device_ctl) () : change_device_control_reply Lwt.t = failwith "not implemented";;
type list_device_properties_reply = { xi_reply_type : int; atoms : Xproto.atom list; };;
let list_device_properties ~(device_id : int) () : list_device_properties_reply Lwt.t = failwith "not implemented";;
type property_format_enum = D8_bits | D16_bits | D32_bits;;
type property_format_variant = D8_bits of { data8 : int list; } | D16_bits of { data16 : int list; } | D32_bits of { data32 : int32 list; };;
let change_device_property ~(property : Xproto.atom) ~(type_ : Xproto.atom) ~(device_id : int) ~(mode : Xproto.prop_mode_enum) ~(num_items : int32) ~(items : property_format_variant) () : unit Lwt.t = failwith "not implemented";;
let delete_device_property ~(property : Xproto.atom) ~(device_id : int) () : unit Lwt.t = failwith "not implemented";;
type get_device_property_reply = { xi_reply_type : int; type_ : Xproto.atom; bytes_after : int32; num_items : int32; device_id : int; items : property_format_variant; };;
let get_device_property ~(property : Xproto.atom) ~(type_ : Xproto.atom) ~(offset : int32) ~(len : int32) ~(device_id : int) ~(delete : bool) () : get_device_property_reply Lwt.t = failwith "not implemented";;
type device_enum = All | All_master;;
type group_info = { base : int; latched : int; locked : int; effective : int; };;
type modifier_info = { base : int32; latched : int32; locked : int32; effective : int32; };;
type xi_query_pointer_reply = { root : Xproto.window; child : Xproto.window; root_x : fp1616; root_y : fp1616; win_x : fp1616; win_y : fp1616; same_screen : bool; mods : modifier_info; group : group_info; buttons : int32 list; };;
let xi_query_pointer ~(window : Xproto.window) ~(deviceid : (device_enum, device_id) alt) () : xi_query_pointer_reply Lwt.t = failwith "not implemented";;
let xi_warp_pointer ~(src_win : Xproto.window) ~(dst_win : Xproto.window) ~(src_x : fp1616) ~(src_y : fp1616) ~(src_width : int) ~(src_height : int) ~(dst_x : fp1616) ~(dst_y : fp1616) ~(deviceid : (device_enum, device_id) alt) () : unit Lwt.t = failwith "not implemented";;
let xi_change_cursor ~(window : Xproto.window) ~(cursor : Xproto.cursor) ~(deviceid : (device_enum, device_id) alt) () : unit Lwt.t = failwith "not implemented";;
type hierarchy_change_type_enum = Add_master | Remove_master | Attach_slave | Detach_slave;;
type change_mode_enum = Attach | Float;;
type add_master = { type_ : hierarchy_change_type_enum; len : int; send_core : bool; enable : bool; name : char list; };;
type remove_master = { type_ : hierarchy_change_type_enum; len : int; deviceid : (device_enum, device_id) alt; return_mode : change_mode_enum; return_pointer : (device_enum, device_id) alt; return_keyboard : (device_enum, device_id) alt; };;
type attach_slave = { type_ : hierarchy_change_type_enum; len : int; deviceid : (device_enum, device_id) alt; master : (device_enum, device_id) alt; };;
type detach_slave = { type_ : hierarchy_change_type_enum; len : int; deviceid : (device_enum, device_id) alt; };;
type hierarchy_change_type_variant = Add_master of { send_core : bool; enable : bool; name : char list; } | Remove_master of { deviceid : (device_enum, device_id) alt; return_mode : change_mode_enum; return_pointer : (device_enum, device_id) alt; return_keyboard : (device_enum, device_id) alt; } | Attach_slave of { deviceid : (device_enum, device_id) alt; master : (device_enum, device_id) alt; } | Detach_slave of { deviceid : (device_enum, device_id) alt; };;
type hierarchy_change = { len : int; data : hierarchy_change_type_variant; };;
let xi_change_hierarchy ~(changes : hierarchy_change list) () : unit Lwt.t = failwith "not implemented";;
let xi_set_client_pointer ~(window : Xproto.window) ~(deviceid : (device_enum, device_id) alt) () : unit Lwt.t = failwith "not implemented";;
type xi_get_client_pointer_reply = { set : bool; deviceid : (device_enum, device_id) alt; };;
let xi_get_client_pointer ~(window : Xproto.window) () : xi_get_client_pointer_reply Lwt.t = failwith "not implemented";;
type xi_event_mask_mask = [ `Device_changed | `Key_press | `Key_release | `Button_press | `Button_release | `Motion | `Enter | `Leave | `Focus_in | `Focus_out | `Hierarchy | `Property | `Raw_key_press | `Raw_key_release | `Raw_button_press | `Raw_button_release | `Raw_motion | `Touch_begin | `Touch_update | `Touch_end | `Touch_ownership | `Raw_touch_begin | `Raw_touch_update | `Raw_touch_end | `Barrier_hit | `Barrier_leave ] list;;
type event_mask = { deviceid : (device_enum, device_id) alt; mask : xi_event_mask_mask list; };;
let xi_select_events ~(window : Xproto.window) ~(masks : event_mask list) () : unit Lwt.t = failwith "not implemented";;
type xi_query_version_reply = { major_version : int; minor_version : int; };;
let xi_query_version ~(major_version : int) ~(minor_version : int) () : xi_query_version_reply Lwt.t = failwith "not implemented";;
type device_class_type_enum = Key | Button | Valuator | Scroll | Touch;;
type device_type_enum = Master_pointer | Master_keyboard | Slave_pointer | Slave_keyboard | Floating_slave;;
type scroll_flags_mask = [ `No_emulation | `Preferred ] list;;
type scroll_type_enum = Vertical | Horizontal;;
type touch_mode_enum = Direct | Dependent;;
type button_class = { type_ : device_class_type_enum; len : int; sourceid : device_id; state : int32 list; labels : Xproto.atom list; };;
type key_class = { type_ : device_class_type_enum; len : int; sourceid : device_id; keys : int32 list; };;
type scroll_class = { type_ : device_class_type_enum; len : int; sourceid : device_id; number : int; scroll_type : scroll_type_enum; flags : scroll_flags_mask; increment : fp3232; };;
type touch_class = { type_ : device_class_type_enum; len : int; sourceid : device_id; mode : touch_mode_enum; num_touches : int; };;
type valuator_class = { type_ : device_class_type_enum; len : int; sourceid : device_id; number : int; label : Xproto.atom; min : fp3232; max : fp3232; value : fp3232; resolution : int32; mode : valuator_mode_enum; };;
type device_class_type_variant = Key of { keys : int32 list; } | Button of { state : int32 list; labels : Xproto.atom list; } | Valuator of { number : int; label : Xproto.atom; min : fp3232; max : fp3232; value : fp3232; resolution : int32; mode : valuator_mode_enum; } | Scroll of { number : int; scroll_type : scroll_type_enum; flags : scroll_flags_mask; increment : fp3232; } | Touch of { mode : touch_mode_enum; num_touches : int; };;
type device_class = { len : int; sourceid : device_id; data : device_class_type_variant; };;
type xi_device_info = { deviceid : (device_enum, device_id) alt; type_ : device_type_enum; attachment : (device_enum, device_id) alt; enabled : bool; name : char list; classes : device_class list; };;
type xi_query_device_reply = { infos : xi_device_info list; };;
let xi_query_device ~(deviceid : (device_enum, device_id) alt) () : xi_query_device_reply Lwt.t = failwith "not implemented";;
let xi_set_focus ~(window : Xproto.window) ~(time : (Xproto.time_enum, Xproto.timestamp) alt) ~(deviceid : (device_enum, device_id) alt) () : unit Lwt.t = failwith "not implemented";;
type xi_get_focus_reply = { focus : Xproto.window; };;
let xi_get_focus ~(deviceid : (device_enum, device_id) alt) () : xi_get_focus_reply Lwt.t = failwith "not implemented";;
type grab_owner_enum = No_owner | Owner;;
type xi_grab_device_reply = { status : Xproto.grab_status_enum; };;
let xi_grab_device ~(window : Xproto.window) ~(time : (Xproto.time_enum, Xproto.timestamp) alt) ~(cursor : Xproto.cursor) ~(deviceid : (device_enum, device_id) alt) ~(mode : Xproto.grab_mode_enum) ~(paired_device_mode : Xproto.grab_mode_enum) ~(owner_events : grab_owner_enum) ~(mask : int32 list) () : xi_grab_device_reply Lwt.t = failwith "not implemented";;
let xi_ungrab_device ~(time : (Xproto.time_enum, Xproto.timestamp) alt) ~(deviceid : (device_enum, device_id) alt) () : unit Lwt.t = failwith "not implemented";;
type event_mode_enum = Async_device | Sync_device | Replay_device | Async_paired_device | Async_pair | Sync_pair | Accept_touch | Reject_touch;;
let xi_allow_events ~(time : (Xproto.time_enum, Xproto.timestamp) alt) ~(deviceid : (device_enum, device_id) alt) ~(event_mode : event_mode_enum) ~(touchid : int32) ~(grab_window : Xproto.window) () : unit Lwt.t = failwith "not implemented";;
type grab_mode22_enum = Sync | Async | Touch;;
type grab_type_enum = Button | Keycode | Enter | Focus_in | Touch_begin;;
type modifier_mask_mask = [ `Any ] list;;
type grab_modifier_info = { modifiers : (modifier_mask_mask, int32) alt; status : Xproto.grab_status_enum; };;
type xi_passive_grab_device_reply = { modifiers : grab_modifier_info list; };;
let xi_passive_grab_device ~(time : (Xproto.time_enum, Xproto.timestamp) alt) ~(grab_window : Xproto.window) ~(cursor : Xproto.cursor) ~(detail : int32) ~(deviceid : (device_enum, device_id) alt) ~(grab_type : grab_type_enum) ~(grab_mode : grab_mode22_enum) ~(paired_device_mode : Xproto.grab_mode_enum) ~(owner_events : grab_owner_enum) ~(mask : int32 list) ~(modifiers : int32 list) () : xi_passive_grab_device_reply Lwt.t = failwith "not implemented";;
let xi_passive_ungrab_device ~(grab_window : Xproto.window) ~(detail : int32) ~(deviceid : (device_enum, device_id) alt) ~(grab_type : grab_type_enum) ~(modifiers : int32 list) () : unit Lwt.t = failwith "not implemented";;
type xi_list_properties_reply = { properties : Xproto.atom list; };;
let xi_list_properties ~(deviceid : (device_enum, device_id) alt) () : xi_list_properties_reply Lwt.t = failwith "not implemented";;
let xi_change_property ~(deviceid : (device_enum, device_id) alt) ~(mode : Xproto.prop_mode_enum) ~(property : Xproto.atom) ~(type_ : Xproto.atom) ~(num_items : int32) ~(items : property_format_variant) () : unit Lwt.t = failwith "not implemented";;
let xi_delete_property ~(deviceid : (device_enum, device_id) alt) ~(property : Xproto.atom) () : unit Lwt.t = failwith "not implemented";;
type xi_get_property_reply = { type_ : Xproto.atom; bytes_after : int32; num_items : int32; items : property_format_variant; };;
let xi_get_property ~(deviceid : (device_enum, device_id) alt) ~(delete : bool) ~(property : Xproto.atom) ~(type_ : Xproto.atom) ~(offset : int32) ~(len : int32) () : xi_get_property_reply Lwt.t = failwith "not implemented";;
type xi_get_selected_events_reply = { masks : event_mask list; };;
let xi_get_selected_events ~(window : Xproto.window) () : xi_get_selected_events_reply Lwt.t = failwith "not implemented";;
type barrier_release_pointer_info = { deviceid : device_id; barrier : Xfixes.barrier; eventid : int32; };;
let xi_barrier_release_pointer ~(barriers : barrier_release_pointer_info list) () : unit Lwt.t = failwith "not implemented";;
type device_valuator_event = { device_id : int; device_state : int; num_valuators : int; first_valuator : int; valuators : int32 list; };;
type more_events_mask_mask = [ `More_events ] list;;
type device_key_press_event = { detail : char; time : Xproto.timestamp; root : Xproto.window; event : Xproto.window; child : (Xproto.window_enum, Xproto.window) alt; root_x : int; root_y : int; event_x : int; event_y : int; state : Xproto.key_but_mask_mask; same_screen : bool; device_id : (more_events_mask_mask, int) alt; };;
type device_key_release_event = device_key_press_event;;
type device_button_press_event = device_key_press_event;;
type device_button_release_event = device_key_press_event;;
type device_motion_notify_event = device_key_press_event;;
type device_focus_in_event = { detail : Xproto.notify_detail_enum; time : Xproto.timestamp; window : Xproto.window; mode : Xproto.notify_mode_enum; device_id : int; };;
type device_focus_out_event = device_focus_in_event;;
type proximity_in_event = device_key_press_event;;
type proximity_out_event = device_key_press_event;;
type classes_reported_mask_mask = [ `Out_of_proximity | `Device_mode_absolute | `Reporting_valuators | `Reporting_buttons | `Reporting_keys ] list;;
type device_state_notify_event = { device_id : (more_events_mask_mask, char) alt; time : Xproto.timestamp; num_keys : int; num_buttons : int; num_valuators : int; classes_reported : classes_reported_mask_mask; buttons : int list; keys : int list; valuators : int32 list; };;
type device_mapping_notify_event = { device_id : char; request : Xproto.mapping_enum; first_keycode : key_code; count : int; time : Xproto.timestamp; };;
type change_device_enum = New_pointer | New_keyboard;;
type change_device_notify_event = { device_id : char; time : Xproto.timestamp; request : change_device_enum; };;
type device_key_state_notify_event = { device_id : (more_events_mask_mask, char) alt; keys : int list; };;
type device_button_state_notify_event = { device_id : (more_events_mask_mask, char) alt; buttons : int list; };;
type device_change_enum = Added | Removed | Enabled | Disabled | Unrecoverable | Control_changed;;
type device_presence_notify_event = { time : Xproto.timestamp; devchange : device_change_enum; device_id : char; control : int; };;
type device_property_notify_event = { state : Xproto.property_enum; time : Xproto.timestamp; property : Xproto.atom; device_id : int; };;
type change_reason_enum = Slave_switch | Device_change;;
type device_changed_event = { deviceid : (device_enum, device_id) alt; time : (Xproto.time_enum, Xproto.timestamp) alt; sourceid : (device_enum, device_id) alt; reason : change_reason_enum; classes : device_class list; };;
type key_event_flags_mask = [ `Key_repeat ] list;;
type key_press_event = { deviceid : (device_enum, device_id) alt; time : (Xproto.time_enum, Xproto.timestamp) alt; detail : int32; root : Xproto.window; event : Xproto.window; child : Xproto.window; root_x : fp1616; root_y : fp1616; event_x : fp1616; event_y : fp1616; sourceid : (device_enum, device_id) alt; flags : key_event_flags_mask; mods : modifier_info; group : group_info; button_mask : int32 list; valuator_mask : int32 list; axisvalues : fp3232 list; };;
type key_release_event = key_press_event;;
type pointer_event_flags_mask = [ `Pointer_emulated ] list;;
type button_press_event = { deviceid : (device_enum, device_id) alt; time : (Xproto.time_enum, Xproto.timestamp) alt; detail : int32; root : Xproto.window; event : Xproto.window; child : Xproto.window; root_x : fp1616; root_y : fp1616; event_x : fp1616; event_y : fp1616; sourceid : (device_enum, device_id) alt; flags : pointer_event_flags_mask; mods : modifier_info; group : group_info; button_mask : int32 list; valuator_mask : int32 list; axisvalues : fp3232 list; };;
type button_release_event = button_press_event;;
type motion_event = button_press_event;;
type notify_mode_enum = Normal | Grab | Ungrab | While_grabbed | Passive_grab | Passive_ungrab;;
type notify_detail_enum = Ancestor | Virtual | Inferior | Nonlinear | Nonlinear_virtual | Pointer | Pointer_root | None;;
type enter_event = { deviceid : (device_enum, device_id) alt; time : (Xproto.time_enum, Xproto.timestamp) alt; sourceid : (device_enum, device_id) alt; mode : notify_mode_enum; detail : notify_detail_enum; root : Xproto.window; event : Xproto.window; child : Xproto.window; root_x : fp1616; root_y : fp1616; event_x : fp1616; event_y : fp1616; same_screen : bool; focus : bool; mods : modifier_info; group : group_info; buttons : int32 list; };;
type leave_event = enter_event;;
type focus_in_event = enter_event;;
type focus_out_event = enter_event;;
type hierarchy_mask_mask = [ `Master_added | `Master_removed | `Slave_added | `Slave_removed | `Slave_attached | `Slave_detached | `Device_enabled | `Device_disabled ] list;;
type hierarchy_info = { deviceid : (device_enum, device_id) alt; attachment : (device_enum, device_id) alt; type_ : device_type_enum; enabled : bool; flags : hierarchy_mask_mask; };;
type hierarchy_event = { deviceid : (device_enum, device_id) alt; time : (Xproto.time_enum, Xproto.timestamp) alt; flags : hierarchy_mask_mask; infos : hierarchy_info list; };;
type property_flag_enum = Deleted | Created | Modified;;
type property_event = { deviceid : (device_enum, device_id) alt; time : (Xproto.time_enum, Xproto.timestamp) alt; property : Xproto.atom; what : property_flag_enum; };;
type raw_key_press_event = { deviceid : (device_enum, device_id) alt; time : (Xproto.time_enum, Xproto.timestamp) alt; detail : int32; sourceid : device_id; flags : key_event_flags_mask; valuator_mask : int32 list; axisvalues : fp3232 list; axisvalues_raw : fp3232 list; };;
type raw_key_release_event = raw_key_press_event;;
type raw_button_press_event = { deviceid : (device_enum, device_id) alt; time : (Xproto.time_enum, Xproto.timestamp) alt; detail : int32; sourceid : device_id; flags : pointer_event_flags_mask; valuator_mask : int32 list; axisvalues : fp3232 list; axisvalues_raw : fp3232 list; };;
type raw_button_release_event = raw_button_press_event;;
type raw_motion_event = raw_button_press_event;;
type touch_event_flags_mask = [ `Touch_pending_end | `Touch_emulating_pointer ] list;;
type touch_begin_event = { deviceid : (device_enum, device_id) alt; time : (Xproto.time_enum, Xproto.timestamp) alt; detail : int32; root : Xproto.window; event : Xproto.window; child : Xproto.window; root_x : fp1616; root_y : fp1616; event_x : fp1616; event_y : fp1616; sourceid : (device_enum, device_id) alt; flags : touch_event_flags_mask; mods : modifier_info; group : group_info; button_mask : int32 list; valuator_mask : int32 list; axisvalues : fp3232 list; };;
type touch_update_event = touch_begin_event;;
type touch_end_event = touch_begin_event;;
type touch_ownership_flags_enum = None;;
type touch_ownership_event = { deviceid : (device_enum, device_id) alt; time : (Xproto.time_enum, Xproto.timestamp) alt; touchid : int32; root : Xproto.window; event : Xproto.window; child : Xproto.window; sourceid : (device_enum, device_id) alt; flags : touch_ownership_flags_enum; };;
type raw_touch_begin_event = { deviceid : (device_enum, device_id) alt; time : (Xproto.time_enum, Xproto.timestamp) alt; detail : int32; sourceid : device_id; flags : touch_event_flags_mask; valuator_mask : int32 list; axisvalues : fp3232 list; axisvalues_raw : fp3232 list; };;
type raw_touch_update_event = raw_touch_begin_event;;
type raw_touch_end_event = raw_touch_begin_event;;
type barrier_flags_mask = [ `Pointer_released | `Device_is_grabbed ] list;;
type barrier_hit_event = { deviceid : (device_enum, device_id) alt; time : (Xproto.time_enum, Xproto.timestamp) alt; eventid : int32; root : Xproto.window; event : Xproto.window; barrier : Xfixes.barrier; dtime : int32; flags : barrier_flags_mask; sourceid : (device_enum, device_id) alt; root_x : fp1616; root_y : fp1616; dx : fp3232; dy : fp3232; };;
type barrier_leave_event = barrier_hit_event;;
type event_for_send = Device_valuator of device_valuator_event | Device_key_press of device_key_press_event | Device_key_release of device_key_release_event | Device_button_press of device_button_press_event | Device_button_release of device_button_release_event | Device_motion_notify of device_motion_notify_event | Device_focus_in of device_focus_in_event | Device_focus_out of device_focus_out_event | Proximity_in of proximity_in_event | Proximity_out of proximity_out_event | Device_state_notify of device_state_notify_event | Device_mapping_notify of device_mapping_notify_event | Change_device_notify of change_device_notify_event | Device_key_state_notify of device_key_state_notify_event | Device_button_state_notify of device_button_state_notify_event | Device_presence_notify of device_presence_notify_event | Device_property_notify of device_property_notify_event;;
let send_extension_event ~(destination : Xproto.window) ~(device_id : int) ~(propagate : bool) ~(events : event_for_send list) ~(classes : event_class list) () : unit Lwt.t = failwith "not implemented";;
type device_error = unit;;
type event_error = unit;;
type mode_error = unit;;
type device_busy_error = unit;;
type class_error = unit;;
end
module[@warning "-27"] Xprint = struct
type string8 = char;;
type printer = { name : string8 list; description : string8 list; };;
type pcontext = xid;;
type get_doc_enum = Finished | Second_consumer;;
type ev_mask_mask = ([ `Print_mask | `Attribute_mask ], [ `No_event_mask ]) mask;;
type detail_enum = Start_job_notify | End_job_notify | Start_doc_notify | End_doc_notify | Start_page_notify | End_page_notify;;
type attr_enum = Job_attr | Doc_attr | Page_attr | Printer_attr | Server_attr | Medium_attr | Spooler_attr;;
type print_query_version_reply = { major_version : int; minor_version : int; };;
let print_query_version () : print_query_version_reply Lwt.t = failwith "not implemented";;
type print_get_printer_list_reply = { printers : printer list; };;
let print_get_printer_list ~(printer_name : string8 list) ~(locale : string8 list) () : print_get_printer_list_reply Lwt.t = failwith "not implemented";;
let print_rehash_printer_list () : unit Lwt.t = failwith "not implemented";;
let create_context ~(context_id : int32) ~(printer_name : string8 list) ~(locale : string8 list) () : unit Lwt.t = failwith "not implemented";;
let print_set_context ~(context : int32) () : unit Lwt.t = failwith "not implemented";;
type print_get_context_reply = { context : int32; };;
let print_get_context () : print_get_context_reply Lwt.t = failwith "not implemented";;
let print_destroy_context ~(context : int32) () : unit Lwt.t = failwith "not implemented";;
type print_get_screen_of_context_reply = { root : Xproto.window; };;
let print_get_screen_of_context () : print_get_screen_of_context_reply Lwt.t = failwith "not implemented";;
let print_start_job ~(output_mode : int) () : unit Lwt.t = failwith "not implemented";;
let print_end_job ~(cancel : bool) () : unit Lwt.t = failwith "not implemented";;
let print_start_doc ~(driver_mode : int) () : unit Lwt.t = failwith "not implemented";;
let print_end_doc ~(cancel : bool) () : unit Lwt.t = failwith "not implemented";;
let print_put_document_data ~(drawable : Xproto.drawable) ~(data : char list) ~(doc_format : string8 list) ~(options : string8 list) () : unit Lwt.t = failwith "not implemented";;
type print_get_document_data_reply = { status_code : int32; finished_flag : int32; data : char list; };;
let print_get_document_data ~(context : pcontext) ~(max_bytes : int32) () : print_get_document_data_reply Lwt.t = failwith "not implemented";;
let print_start_page ~(window : Xproto.window) () : unit Lwt.t = failwith "not implemented";;
let print_end_page ~(cancel : bool) () : unit Lwt.t = failwith "not implemented";;
let print_select_input ~(context : pcontext) ~(event_mask : int32) () : unit Lwt.t = failwith "not implemented";;
type print_input_selected_reply = { event_mask : int32; all_events_mask : int32; };;
let print_input_selected ~(context : pcontext) () : print_input_selected_reply Lwt.t = failwith "not implemented";;
type print_get_attributes_reply = { attributes : string8 list; };;
let print_get_attributes ~(context : pcontext) ~(pool : int) () : print_get_attributes_reply Lwt.t = failwith "not implemented";;
type print_get_one_attributes_reply = { value : string8 list; };;
let print_get_one_attributes ~(context : pcontext) ~(pool : int) ~(name : string8 list) () : print_get_one_attributes_reply Lwt.t = failwith "not implemented";;
let print_set_attributes ~(context : pcontext) ~(string_len : int32) ~(pool : int) ~(rule : int) ~(attributes : string8 list) () : unit Lwt.t = failwith "not implemented";;
type print_get_page_dimensions_reply = { width : int; height : int; offset_x : int; offset_y : int; reproducible_width : int; reproducible_height : int; };;
let print_get_page_dimensions ~(context : pcontext) () : print_get_page_dimensions_reply Lwt.t = failwith "not implemented";;
type print_query_screens_reply = { roots : Xproto.window list; };;
let print_query_screens () : print_query_screens_reply Lwt.t = failwith "not implemented";;
type print_set_image_resolution_reply = { status : bool; previous_resolutions : int; };;
let print_set_image_resolution ~(context : pcontext) ~(image_resolution : int) () : print_set_image_resolution_reply Lwt.t = failwith "not implemented";;
type print_get_image_resolution_reply = { image_resolution : int; };;
let print_get_image_resolution ~(context : pcontext) () : print_get_image_resolution_reply Lwt.t = failwith "not implemented";;
type notify_event = { detail : int; context : pcontext; cancel : bool; };;
type attribut_notify_event = { detail : int; context : pcontext; };;
type bad_context_error = unit;;
type bad_sequence_error = unit;;
end
module[@warning "-27"] Xselinux = struct
type query_version_reply = { server_major : int; server_minor : int; };;
let query_version ~(client_major : int) ~(client_minor : int) () : query_version_reply Lwt.t = failwith "not implemented";;
let set_device_create_context ~(context : char list) () : unit Lwt.t = failwith "not implemented";;
type get_device_create_context_reply = { context : char list; };;
let get_device_create_context () : get_device_create_context_reply Lwt.t = failwith "not implemented";;
let set_device_context ~(device : int32) ~(context : char list) () : unit Lwt.t = failwith "not implemented";;
type get_device_context_reply = { context : char list; };;
let get_device_context ~(device : int32) () : get_device_context_reply Lwt.t = failwith "not implemented";;
let set_window_create_context ~(context : char list) () : unit Lwt.t = failwith "not implemented";;
type get_window_create_context_reply = { context : char list; };;
let get_window_create_context () : get_window_create_context_reply Lwt.t = failwith "not implemented";;
type get_window_context_reply = { context : char list; };;
let get_window_context ~(window : Xproto.window) () : get_window_context_reply Lwt.t = failwith "not implemented";;
type list_item = { name : Xproto.atom; object_context : char list; data_context : char list; };;
let set_property_create_context ~(context : char list) () : unit Lwt.t = failwith "not implemented";;
type get_property_create_context_reply = { context : char list; };;
let get_property_create_context () : get_property_create_context_reply Lwt.t = failwith "not implemented";;
let set_property_use_context ~(context : char list) () : unit Lwt.t = failwith "not implemented";;
type get_property_use_context_reply = { context : char list; };;
let get_property_use_context () : get_property_use_context_reply Lwt.t = failwith "not implemented";;
type get_property_context_reply = { context : char list; };;
let get_property_context ~(window : Xproto.window) ~(property : Xproto.atom) () : get_property_context_reply Lwt.t = failwith "not implemented";;
type get_property_data_context_reply = { context : char list; };;
let get_property_data_context ~(window : Xproto.window) ~(property : Xproto.atom) () : get_property_data_context_reply Lwt.t = failwith "not implemented";;
type list_properties_reply = { properties : list_item list; };;
let list_properties ~(window : Xproto.window) () : list_properties_reply Lwt.t = failwith "not implemented";;
let set_selection_create_context ~(context : char list) () : unit Lwt.t = failwith "not implemented";;
type get_selection_create_context_reply = { context : char list; };;
let get_selection_create_context () : get_selection_create_context_reply Lwt.t = failwith "not implemented";;
let set_selection_use_context ~(context : char list) () : unit Lwt.t = failwith "not implemented";;
type get_selection_use_context_reply = { context : char list; };;
let get_selection_use_context () : get_selection_use_context_reply Lwt.t = failwith "not implemented";;
type get_selection_context_reply = { context : char list; };;
let get_selection_context ~(selection : Xproto.atom) () : get_selection_context_reply Lwt.t = failwith "not implemented";;
type get_selection_data_context_reply = { context : char list; };;
let get_selection_data_context ~(selection : Xproto.atom) () : get_selection_data_context_reply Lwt.t = failwith "not implemented";;
type list_selections_reply = { selections : list_item list; };;
let list_selections () : list_selections_reply Lwt.t = failwith "not implemented";;
type get_client_context_reply = { context : char list; };;
let get_client_context ~(resource : int32) () : get_client_context_reply Lwt.t = failwith "not implemented";;
end
module[@warning "-27"] Xtest = struct
type get_version_reply = { major_version : int; minor_version : int; };;
let get_version ~(major_version : int) ~(minor_version : int) () : get_version_reply Lwt.t = failwith "not implemented";;
type cursor_enum = None | Current;;
type compare_cursor_reply = { same : bool; };;
let compare_cursor ~(window : Xproto.window) ~(cursor : Xproto.cursor) () : compare_cursor_reply Lwt.t = failwith "not implemented";;
let fake_input ~(type_ : char) ~(detail : char) ~(time : int32) ~(root : Xproto.window) ~(root_x : int) ~(root_y : int) ~(deviceid : int) () : unit Lwt.t = failwith "not implemented";;
let grab_control ~(impervious : bool) () : unit Lwt.t = failwith "not implemented";;
end
module[@warning "-27"] Xv = struct
type port = xid;;
type encoding = xid;;
type type_mask = [ `Input_mask | `Output_mask | `Video_mask | `Still_mask | `Image_mask ] list;;
type image_format_info_type_enum = Rgb | Yuv;;
type image_format_info_format_enum = Packed | Planar;;
type attribute_flag_mask = [ `Gettable | `Settable ] list;;
type video_notify_reason_enum = Started | Stopped | Busy | Preempted | Hard_error;;
type scanline_order_enum = Top_to_bottom | Bottom_to_top;;
type grab_port_status_enum = Success | Bad_extension | Already_grabbed | Invalid_time | Bad_reply | Bad_alloc;;
type rational = { numerator : int32; denominator : int32; };;
type format = { visual : Xproto.visualid; depth : int; };;
type adaptor_info = { base_id : port; num_ports : int; type_ : type_mask; name : char list; formats : format list; };;
type encoding_info = { encoding : encoding; width : int; height : int; rate : rational; name : char list; };;
type image = { id : int32; width : int; height : int; pitches : int32 list; offsets : int32 list; data : int list; };;
type attribute_info = { flags : attribute_flag_mask; min : int32; max : int32; name : char list; };;
type image_format_info = { id : int32; type_ : image_format_info_type_enum; byte_order : Xproto.image_order_enum; guid : int list; bpp : int; num_planes : int; depth : int; red_mask : int32; green_mask : int32; blue_mask : int32; format : image_format_info_format_enum; y_sample_bits : int32; u_sample_bits : int32; v_sample_bits : int32; vhorz_y_period : int32; vhorz_u_period : int32; vhorz_v_period : int32; vvert_y_period : int32; vvert_u_period : int32; vvert_v_period : int32; vcomp_order : int list; vscanline_order : scanline_order_enum; };;
type bad_port_error = unit;;
type bad_encoding_error = unit;;
type bad_control_error = unit;;
type video_notify_event = { reason : video_notify_reason_enum; time : Xproto.timestamp; drawable : Xproto.drawable; port : port; };;
type port_notify_event = { time : Xproto.timestamp; port : port; attribute : Xproto.atom; value : int32; };;
type query_extension_reply = { major : int; minor : int; };;
let query_extension () : query_extension_reply Lwt.t = failwith "not implemented";;
type query_adaptors_reply = { info : adaptor_info list; };;
let query_adaptors ~(window : Xproto.window) () : query_adaptors_reply Lwt.t = failwith "not implemented";;
type query_encodings_reply = { info : encoding_info list; };;
let query_encodings ~(port : port) () : query_encodings_reply Lwt.t = failwith "not implemented";;
type grab_port_reply = { result : grab_port_status_enum; };;
let grab_port ~(port : port) ~(time : (Xproto.time_enum, Xproto.timestamp) alt) () : grab_port_reply Lwt.t = failwith "not implemented";;
let ungrab_port ~(port : port) ~(time : (Xproto.time_enum, Xproto.timestamp) alt) () : unit Lwt.t = failwith "not implemented";;
let put_video ~(port : port) ~(drawable : Xproto.drawable) ~(gc : Xproto.gcontext) ~(vid_x : int) ~(vid_y : int) ~(vid_w : int) ~(vid_h : int) ~(drw_x : int) ~(drw_y : int) ~(drw_w : int) ~(drw_h : int) () : unit Lwt.t = failwith "not implemented";;
let put_still ~(port : port) ~(drawable : Xproto.drawable) ~(gc : Xproto.gcontext) ~(vid_x : int) ~(vid_y : int) ~(vid_w : int) ~(vid_h : int) ~(drw_x : int) ~(drw_y : int) ~(drw_w : int) ~(drw_h : int) () : unit Lwt.t = failwith "not implemented";;
let get_video ~(port : port) ~(drawable : Xproto.drawable) ~(gc : Xproto.gcontext) ~(vid_x : int) ~(vid_y : int) ~(vid_w : int) ~(vid_h : int) ~(drw_x : int) ~(drw_y : int) ~(drw_w : int) ~(drw_h : int) () : unit Lwt.t = failwith "not implemented";;
let get_still ~(port : port) ~(drawable : Xproto.drawable) ~(gc : Xproto.gcontext) ~(vid_x : int) ~(vid_y : int) ~(vid_w : int) ~(vid_h : int) ~(drw_x : int) ~(drw_y : int) ~(drw_w : int) ~(drw_h : int) () : unit Lwt.t = failwith "not implemented";;
let stop_video ~(port : port) ~(drawable : Xproto.drawable) () : unit Lwt.t = failwith "not implemented";;
let select_video_notify ~(drawable : Xproto.drawable) ~(onoff : bool) () : unit Lwt.t = failwith "not implemented";;
let select_port_notify ~(port : port) ~(onoff : bool) () : unit Lwt.t = failwith "not implemented";;
type query_best_size_reply = { actual_width : int; actual_height : int; };;
let query_best_size ~(port : port) ~(vid_w : int) ~(vid_h : int) ~(drw_w : int) ~(drw_h : int) ~(motion : bool) () : query_best_size_reply Lwt.t = failwith "not implemented";;
let set_port_attribute ~(port : port) ~(attribute : Xproto.atom) ~(value : int32) () : unit Lwt.t = failwith "not implemented";;
type get_port_attribute_reply = { value : int32; };;
let get_port_attribute ~(port : port) ~(attribute : Xproto.atom) () : get_port_attribute_reply Lwt.t = failwith "not implemented";;
type query_port_attributes_reply = { text_size : int32; attributes : attribute_info list; };;
let query_port_attributes ~(port : port) () : query_port_attributes_reply Lwt.t = failwith "not implemented";;
type list_image_formats_reply = { format : image_format_info list; };;
let list_image_formats ~(port : port) () : list_image_formats_reply Lwt.t = failwith "not implemented";;
type query_image_attributes_reply = { data_size : int32; width : int; height : int; pitches : int32 list; offsets : int32 list; };;
let query_image_attributes ~(port : port) ~(id : int32) ~(width : int) ~(height : int) () : query_image_attributes_reply Lwt.t = failwith "not implemented";;
let put_image ~(port : port) ~(drawable : Xproto.drawable) ~(gc : Xproto.gcontext) ~(id : int32) ~(src_x : int) ~(src_y : int) ~(src_w : int) ~(src_h : int) ~(drw_x : int) ~(drw_y : int) ~(drw_w : int) ~(drw_h : int) ~(width : int) ~(height : int) ~(data : int list) () : unit Lwt.t = failwith "not implemented";;
let shm_put_image ~(port : port) ~(drawable : Xproto.drawable) ~(gc : Xproto.gcontext) ~(shmseg : Shm.seg) ~(id : int32) ~(offset : int32) ~(src_x : int) ~(src_y : int) ~(src_w : int) ~(src_h : int) ~(drw_x : int) ~(drw_y : int) ~(drw_w : int) ~(drw_h : int) ~(width : int) ~(height : int) ~(send_event : int) () : unit Lwt.t = failwith "not implemented";;
end
module[@warning "-27"] Xvmc = struct
type context = xid;;
type surface = xid;;
type subpicture = xid;;
type surface_info = { id : surface; chroma_format : int; pad0 : int; max_width : int; max_height : int; subpicture_max_width : int; subpicture_max_height : int; mc_type : int32; flags : int32; };;
type query_version_reply = { major : int32; minor : int32; };;
let query_version () : query_version_reply Lwt.t = failwith "not implemented";;
type list_surface_types_reply = { surfaces : surface_info list; };;
let list_surface_types ~(port_id : Xv.port) () : list_surface_types_reply Lwt.t = failwith "not implemented";;
type create_context_reply = { width_actual : int; height_actual : int; flags_return : int32; priv_data : int32 list; };;
let create_context ~(context_id : context) ~(port_id : Xv.port) ~(surface_id : surface) ~(width : int) ~(height : int) ~(flags : int32) () : create_context_reply Lwt.t = failwith "not implemented";;
let destroy_context ~(context_id : context) () : unit Lwt.t = failwith "not implemented";;
type create_surface_reply = { priv_data : int32 list; };;
let create_surface ~(surface_id : surface) ~(context_id : context) () : create_surface_reply Lwt.t = failwith "not implemented";;
let destroy_surface ~(surface_id : surface) () : unit Lwt.t = failwith "not implemented";;
type create_subpicture_reply = { width_actual : int; height_actual : int; num_palette_entries : int; entry_bytes : int; component_order : int list; priv_data : int32 list; };;
let create_subpicture ~(subpicture_id : subpicture) ~(context : context) ~(xvimage_id : int32) ~(width : int) ~(height : int) () : create_subpicture_reply Lwt.t = failwith "not implemented";;
let destroy_subpicture ~(subpicture_id : subpicture) () : unit Lwt.t = failwith "not implemented";;
type list_subpicture_types_reply = { types : Xv.image_format_info list; };;
let list_subpicture_types ~(port_id : Xv.port) ~(surface_id : surface) () : list_subpicture_types_reply Lwt.t = failwith "not implemented";;
end
